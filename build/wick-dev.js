var wick = (function (exports) {
    'use strict';

    /**
     * Global Document instance short name
     * @property DOC
     * @package
     * @memberof module:wick~internals
     * @type 	{Document}
     */
    const DOC = document;

    /**
     * Global Window Instance short name
     * @property WIN
     * @package
     * @memberof module:wick~internals
     * @type 	{Window}
     */
    const WIN = window;

    /**
     * Global HTMLElement class short name
     * @property EL
     * @package
     * @memberof module:wick~internals
     * @type 	{HTMLElement}
     */
    const EL = HTMLElement;

    /**
     * Global Object class short name
     * @property OB
     * @package
     * @memberof module:wick~internals
     * @type Object
     */
    const OB = Object;

    /***************** Functions ********************/

    /**
     *  Global document.createElement short name function.
     * @method DOC
     * @package
     * @memberof module:wick~internals
     * @param 	{String}  		e   - tagname of element to create. 
     * @return  {HTMLElement}  		- HTMLElement instance generated by the document. 
     */
    const _createElement_ = (e) => DOC.createElement(e);

    /**
     *  Element.prototype.appendChild short name wrapper.
     * @method _appendChild_
     * @package
     * @memberof module:wick~internals
     * @param 	{HTMLElement}  		el  	- parent HTMLElement.
     * @return  {HTMLElement | HTMLNode}  		ch_el 	- child HTMLElement or HTMLNode. 
     */
    const _appendChild_ = (el, ch_el) => el.appendChild(ch_el);

    /**
     *  Element.prototype.cloneNode short name wrapper.
     * @method _cloneNode_
     * @package
     * @memberof module:wick~internals
     * @param 	{HTMLElement}  		el   - HTMLElement to clone.
     * @return  {Boolean}  			bool - Switch for deep clone
     */
    const _cloneNode_ = (el, bool) => el.cloneNode(bool);

    const _SealedProperty_ = (object, name, value) => OB.defineProperty(object, name, {value, configurable: false, enumerable: false, writable: true});
    const _FrozenProperty_ = (object, name, value) => OB.defineProperty(object, name, {value, configurable: false, enumerable: false, writable: false});

    /**
     * Used to call the Scheduler after a JavaScript runtime tick.
     *
     * Depending on the platform, caller will either map to requestAnimationFrame or it will be a setTimout.
     * @memberof Scheduler
     * @private
     */
    const caller = (window && window.requestAnimationFrame) ? window.requestAnimationFrame : (f) => {
        setTimeout(f, 1);
    };



    /**
     * Handles updating objects. It does this by splitting up _update_ cycles, to respect the browser event model. 
     *    
     * If any object is scheduled to be updated, it will be blocked from scheduling more updates the next JavaScript runtime tick.
     * 
     * @memberof module:wick~internals
     * @alias Scheduler
     */
    class Scheduler {
        /**
         * Constructs the object.
         */
        constructor() {

            this.update_queue_a = [];
            this.update_queue_b = [];

            this.update_queue = this.update_queue_a;

            this.queue_switch = 0;

            this.callback = () => this._update_();

            this.frame_time = performance.now();

            this._SCHD_ = false;


        }

        /**
         * Given an object that has a _SCHD_ Boolean property, the Scheduler will queue the object and call its ._update_ function 
         * the following tick. If the object does not have a _SCHD_ property, the Scheduler will persuade the object to have such a property.
         * 
         * If there are currently no queued objects when this is called, then the Scheduler will user caller to schedule an _update_.
         *
         * @param      {Object}  object  The object to have updated.
         */
        queueUpdate(object, timestart = 1, timeend = 0) {
            if (object._SCHD_ || object._SCHD_ > 0)
                if (this._SCHD_)
                    return;
                else
                    return caller(this.callback);

            object._SCHD_ = (timestart | ((timestart + timeend) << 16));

            this.update_queue.push(object);

            if (this._SCHD_)
                return;

            this._SCHD_ = true;

            caller(this.callback);
        }

        /**
         * Called by the caller function every tick. Calls ._update_ on any object queued for an _update_. 
         */
        _update_() {

            this._SCHD_ = false;

            let uq = this.update_queue;

            if (this.queue_switch == 0)
                (this.update_queue = this.update_queue_b, this.queue_switch = 1);
            else
                (this.update_queue = this.update_queue_a, this.queue_switch = 0);

            let time = performance.now() | 0;

            let diff = Math.ceil(time - this.frame_time) | 1;

            this.frame_time = time;

            let step_ratio = (diff * 0.06); //  step_ratio of 1 = 16.66666666 or 1000 / 60 for 60 FPS


            for (let i = 0, l = uq.length, o = uq[0]; i < l; o = uq[++i]) {
                let timestart = ((o._SCHD_ & 65535)) - diff;
                let timeend = ((o._SCHD_ >> 16) & 65535) - diff;


                if (timestart > 0) {
                    o._SCHD_ = 0;
                    this.queueUpdate(o, timestart, timeend);
                    continue;
                }


                if (timeend > 0) {
                    this.queueUpdate(o, timestart, timeend);
                    continue;
                } else o._SCHD_ = 0;

                o._scheduledUpdate_(step_ratio);
            }

            uq.length = 0;
        }
    }

    const scheduler = new Scheduler();

    /**
     * The base class which all Model classes extend.
     * @memberof module:wick~internal ._model_
     * @alias ModelBase
     */
    class ModelBase {
        constructor(root = null, address = []) {
            _SealedProperty_(this, "_cv_", []);
            _SealedProperty_(this, "fv", null);
            _SealedProperty_(this, "par", null);
            _SealedProperty_(this, "MUTATION_ID", 0);
            _SealedProperty_(this, "address", address);
            _SealedProperty_(this, "root", root || this);
            _SealedProperty_(this, "prop_name", "");
        }


        /**
         *   Remove all references to any objects still held by this object.
         *   @protected
         *   @instance
         */
        _destroy_() {

            //inform views of the models demise
            var view = this.fv;

            while (view) {
                let nx = view.nx;
                view.unsetModel();
                view = nx;
            }

            this._cv_ = null;
        }

        setHook(prop_name, data) { return data; }

        getHook(prop_name, data) { return data; }


        /**
         * Called by a class that extends ModelBase when on of its property values changes.
         * @param      {string}  changed_value  The changed value
         * @private
         */
        scheduleUpdate(changed_value) {
            if (!this.fv)
                return;


            this._cv_.push(changed_value);

            scheduler.queueUpdate(this);
        }


        getChanged(prop_name) {


            for (let i = 0, l = this._cv_.length; i < l; i++)
                if (this._cv_[i] == prop_name)
                    return this[prop_name];

            return null;
        }

        addListener(listener) {
            return this.addView(listener);
        }


        /**
         * Adds a view to the linked list of views on the model. argument view MUST be an instance of View. 
         * @param {View} view - The view to _bind_ to the ModelBase
         * @throws {Error} throws an error if the value of `view` is not an instance of {@link View}.
         */
        addView(view) {
            if (view._model_)
                if (view._model_ !== this) {
                    view._model_.removeView(view);
                } else return;

            if (this.fv) this.fv.pv = view;
            view.nx = this.fv;
            this.fv = view;

            view.pv = null;
            view._model_ = this;
            view._update_(this);
        }

        /**
         * Removes view from set of views if the passed in view is a member of model. 
         * @param {View} view - The view to unbind from ModelBase
         */
        removeView(view) {
            

            if (view._model_ == this) {
                if (view == this.fv)
                    this.fv = view.nx;

                if (view.nx)
                    view.nx.pv = view.pv;
                if (view.pv)
                    view.pv.nx = view.nx;

                view.nx = null;
                view.pv = null;
            }
        }


        /**
            Should return the value of the property if it is in the model and has been updated since the last cycle. Null otherwise.
            This should be overridden by a more efficient version by inheriting objects
        */
        isUpdated(prop_name) {

            let changed_properties = this._cv_;

            for (var i = 0, l = changed_properties.length; i < l; i++)
                if (changed_properties[i] == prop_name)
                    if (this[prop_name] !== undefined)
                        return this[prop_name];

            return null;
        }



        /**
         * Called by the {@link Scheduler} when if the ModelBase is scheduled for an _update_
         * @param      {number}  step    The step
         */
        _scheduledUpdate_(step) { this.updateViews(); }



        /**
         * Calls View#_update_ on every bound View, passing the current state of the ModelBase.
         */
        updateViews() {

            let o = {};

            for (let p = null, i = 0, l = this._cv_.length; i < l; i++)
                (p = this._cv_[i], o[p] = this[p]);

            this._cv_.length = 0;

            var view = this.fv;

            while (view) {

                view._update_(this, o);
                view = view.nx;
            }

            return;
        }



        /**
         * Updates views with a list of models that have been removed. 
         * Primarily used in conjunction with container based views, such as Templates.
         * @private
         */
        updateViewsRemoved(data) {

            var view = this.fv;

            while (view) {

                view.removed(data);

                view = view.nx;
            }
        }



        /** MUTATION FUNCTIONS **************************************************************************************/



        _deferUpdateToRoot_(data, MUTATION_ID = this.MUTATION_ID) {
            return this.root._setThroughRoot_(data, this.address, 0, this.address.length, MUTATION_ID);
        }



        _setThroughRoot_(data, address, index, len, m_id) {

            if (index >= len) {

                if (m_id !== this.MUTATION_ID) {
                    let clone = this.clone();
                    clone.set(data, true);
                    clone.MUTATION_ID = (this.par) ? this.par.MUTATION_ID : this.MUTATION_ID + 1;
                    return clone;
                }

                this.set(data, true);
                return this;
            }

            let i = address[index++];

            let model_prop = this.prop_array[i];

            if (model_prop.MUTATION_ID !== this.MUTATION_ID) {

                model_prop = model_prop.clone();

                model_prop.MUTATION_ID = this.MUTATION_ID;
            }

            this.prop_array[i] = model_prop;

            return model_prop._setThroughRoot_(data, address, index, len, model_prop.MUTATION_ID);
        }

        seal() {

            let clone = this._deferUpdateToRoot_(null, this.MUTATION_ID + 1);

            return clone;
        }

        clone() {

            let clone = new this.constructor(this);

            clone.prop_name = this.prop_name;
            clone._cv_ = this._cv_;
            clone.fv = this.fv;
            clone.par = this.par;
            clone.MUTATION_ID = this.MUTATION_ID;
            clone.address = this.address;
            clone.prop_name = this.prop_name;

            clone.root = (this.root == this) ? clone : this.root;

            return clone;
        }

        /**
         * Updates views with a list of models that have been added. 
         * Primarily used in conjunction with container based views, such as Templates.
         * @private
         */
        updateViewsAdded(data) {

            var view = this.fv;

            while (view) {

                view.added(data);

                view = view.nx;
            }
        }

        toJson() { return JSON.stringify(this, null, '\t'); }


        /**
         * This will update the branch state of the data tree with a new branch if the MUTATION_ID is higher or lower than the current branch's parent level.
         * In this case, the new branch will stem from the root node, and all ancestor nodes from the originating child will be cloned.
         *
         * @param      {Object}         child_obj    The child object
         * @param      {(Object|number)}  MUTATION_ID  The mutation id
         * @return     {Object}         { description_of_the_return_value }
         */
        setMutation(child_obj, MUTATION_ID = child_obj.MUTATION_ID) {
            let clone = child_obj,
                result = this;

            if (MUTATION_ID == this.MUTATION_ID) return child_obj;

            if (this.par)
                result = this.par.setMutation(this, MUTATION_ID);

            if (MUTATION_ID > this.MUTATION_ID) {
                result = this.clone();
                result.MUTATION_ID = this.MUTATION_ID + 1;
            }

            clone = child_obj.clone();
            clone.MUTATION_ID = result.MUTATION_ID;
            result[clone.prop_name] = clone;

            return clone;
        }
    }

    /**
        Schema type. Handles the parsing, validation, and filtering of Model data properties. 
    */
    class SchemeConstructor {

        constructor() {

            this.start_value = undefined;
        }

        /**
            Parses value returns an appropriate transformed value
        */
        parse(value) {

            return value;
        }

        /**

        */
        verify(value, result) {

            result.valid = true;
        }

        filter(id, filters) {
            for (let i = 0, l = filters.length; i < l; i++)
                if (id === filters[i]) return true;
            return false;
        }

        string(value) {

            return value + "";
        }
    }

    class MCArray extends Array {

        constructor() {
            super();
        }

        push(item) {
            if (item instanceof Array)
                item.forEach((i) => {
                    this.push(i);
                });
            else
                super.push(item);
        }

        //For compatibility
        __setFilters__() {

        }

        getChanged() {

        }

        toJSON() { return this; }

        toJson() { return JSON.stringify(this, null, '\t'); }
    }
    let EmptyArray = [];

    class ModelContainerBase extends ModelBase {

        constructor(root = null, address = []) {

            super(root, address);

            _SealedProperty_(this, "source", null);
            _SealedProperty_(this, "first_link", null);

            //For keeping the container from garbage collection.
            _SealedProperty_(this, "pin", EmptyArray);

            //For Linking to original 
            _SealedProperty_(this, "next", null);
            _SealedProperty_(this, "prev", null);

            //Filters are a series of strings or number selectors used to determine if a model should be inserted into or retrieved from the container.
            _SealedProperty_(this, "__filters__", null);

            this.validator = new SchemeConstructor();

            return this;
        }

        setByIndex(index) { /* NO OP **/ }

        getByIndex(index, value) { /* NO OP **/ }

        _destroy_() {


            this.__filters__ = null;

            if (this.source) {
                this.source.__unlink__(this);
            }

            super._destroy_();
        }

        /**
            Get the number of Models held in this._mContainerBase

            @returns {Number}
        */
        get length() { return 0; }

        set length(e) { /* NO OP */ }

        /** 
            Returns a ModelContainerBase type to store the results of a get().
        */
        __defaultReturn__(USE_ARRAY) {
            if (USE_ARRAY) return new MCArray;

            let n = new this.constructor();

            n.key = this.key;
            n.validator = this.validator;
            n.model = this.model;

            this.__link__(n);

            return n;
        }

        /**
            Array emulating kludge

            @returns The result of calling this.insert
        */
        push(item) { return this.insert(item, false, true); }

        /**
            Retrieves a list of items that match the term/terms. 

            @param {(Array|SearchTerm)} term - A single term or a set of terms to look for in the ModelContainerBase. 
            @param {Array} __return_data__ - Set to true by a source Container if it is calling a SubContainer insert function. 

            @returns {(ModelContainerBase|Array)} Returns a Model container or an Array of Models matching the search terms. 
        */
        get(term, __return_data__) {

            let out = null;

            term = this.getHook("term", term);

            let USE_ARRAY = (__return_data__ === null) ? false : true;

            if (term) {

                if (__return_data__) {
                    out = __return_data__;
                } else {

                    if (!this.source)
                        USE_ARRAY = false;

                    out = this.__defaultReturn__(USE_ARRAY);
                    out.__setFilters__(term);
                }
            } else
                out = (__return_data__) ? __return_data__ : this.__defaultReturn__(USE_ARRAY);

            if (!term)
                this.__getAll__(out);
            else {

                let terms = term;

                if (!Array.isArray(term))
                    terms = [term];

                //Need to convert terms into a form that will work for the identifier type
                terms = terms.map(t => this.validator.parse(t));

                this.__get__(terms, out);
            }

            return out;
        }

        set(item, from_root = false) {
            if (!from_root)
                return this._deferUpdateToRoot_(item).insert(item);
            else
                this.insert(item);
        }

        /**
            Inserts an item into the container. If the item is not a {Model}, an attempt will be made to convert the data in the Object into a Model.
            If the item is an array of objects, each object in the array will be considered separately. 

            @param {Object} item - An Object to insert into the container. On of the properties of the object MUST have the same name as the ModelContainerBase's 
            @param {Array} item - An array of Objects to insert into the container.
            @param {Boolean} __FROM_SOURCE__ - Set to true by a source Container if it is calling a SubContainer insert function. 

            @returns {Boolean} Returns true if an insertion into the ModelContainerBase occurred, false otherwise.
        */
        insert(item, __FROM_SOURCE__ = false) {

            let add_list = (this.fv) ? [] : null;

            let out_data = false;

            if (!__FROM_SOURCE__ && this.source)
                return this.source.insert(item);


            if (item instanceof Array) {
                for (var i = 0; i < item.length; i++)
                    if (this.__insertSub__(item[i], out_data, add_list))
                        out_data = true;
            } else if (item)
                out_data = this.__insertSub__(item, out_data, add_list);


            if (out_data) {
                if (this.par)
                    this.par.scheduleUpdate(this.prop_name);


                if (add_list && add_list.length > 0) {
                    this.updateViewsAdded(add_list);
                    this.scheduleUpdate();
                }
            }

            return out_data;
        }

        /**
            A subset of the insert function. Handles the test of identifier, the conversion of an Object into a Model, and the calling of the internal __insert__ function.
        */
        __insertSub__(item, out, add_list) {

            let model = item;

            var identifier = this._gI_(item);

            if (identifier != undefined) {

                if (!(model instanceof ModelBase)) {
                    model = new this.model(item);
                    model.MUTATION_ID = this.MUTATION_ID;
                }

                identifier = this._gI_(model, this.__filters__);

                if (identifier) {
                    out = this.__insert__(model, add_list, identifier);
                    this.__linksInsert__(model);
                }
            }

            return out;
        }

        delete(term, from_root = false) {
            if (!from_root)
                return this._deferUpdateToRoot_(term).remove(term);
            else
                this.remove(term);
        }

        /**
            Removes an item from the container. 
        */
        remove(term, __FROM_SOURCE__ = false) {

            //term = this.getHook("term", term);

            if (!__FROM_SOURCE__ && this.source) {

                if (!term)
                    return this.source.remove(this.__filters__);
                else
                    return this.source.remove(term);
            }

            let out_container = [];

            if (!term)
                this.__removeAll__();

            else {

                let terms = (Array.isArray(term)) ? term : [term];

                //Need to convert terms into a form that will work for the identifier type
                terms = terms.map(t => (t instanceof ModelBase) ? t : this.validator.parse(t));

                this.__remove__(terms, out_container);
            }

            return out_container;
        }

        /**
            Removes a ModelContainerBase from list of linked containers. 

            @param {ModelContainerBase} container - The ModelContainerBase instance to remove from the set of linked containers. Must be a member of the linked containers. 
        */
        __unlink__(container) {

            if (container instanceof ModelContainerBase && container.source == this) {

                if (container == this.first_link)
                    this.first_link = container.next;

                if (container.next)
                    container.next.prev = container.prev;

                if (container.prev)
                    container.prev.next = container.next;

                container.source = null;
            }
        }

        /**
            Adds a container to the list of tracked containers. 

            @param {ModelContainerBase} container - The ModelContainerBase instance to add the set of linked containers.
        */
        __link__(container) {
            if (container instanceof ModelContainerBase && !container.source) {

                container.source = this;

                container.next = this.first_link;

                if (this.first_link)
                    this.first_link.prev = container;

                this.first_link = container;

                container.pin = ((container) => {
                    let id = setTimeout(() => {
                        container.__unlink__();
                    }, 50);

                    return () => {
                        clearTimeout(id);
                        if (!container.source)
                            console.warn("failed to clear the destruction of container in time!");
                    };
                })(container);
            }
        }

        /**
         * Remove items from linked ModelContainers according to the terms provided.
         * @param      {Array}  terms   Array of terms.
         * @private
         */
        __linksRemove__(item) {
            let a = this.first_link;
            while (a) {
                for (let i = 0; i < item.length; i++)
                    if (a._gI_(item[i], a.__filters__)) {
                        a.scheduleUpdate();
                        break;
                    }

                a = a.next;
            }
        }

        /**
         * Add items to linked ModelContainers.
         * @param      {Model}  item   Item to add.
         * @private
         */
        __linksInsert__(item) {
            let a = this.first_link;
            while (a) {
                if (a._gI_(item, a.__filters__))
                    a.scheduleUpdate();
                a = a.next;
            }
        }

        /**
            Removes any items in the ModelConatiner not included in the array "items", and adds any item in `items` not already in the ModelContainerBase.
            @param {Array} items - An array of identifiable Models or objects. 
        */
        cull(items) {
            let existing_items = __getAll__([], true);

            let loadHash = (item) => {
                if (item instanceof Array)
                    return item.forEach((e) => loadHash(e));

                let identifier = this._gI_(item);

            };

            loadHash(items);

            for (let i = 0; i < existing_items.lenth; i++) {
                let e_item = existing_items[i];
                if (!existing_items[this._gI_(e_item)])
                    this.__remove__(e_item);
            }

            this.insert(items);
        }

        __setFilters__(term) {

            if (!this.__filters__) this.__filters__ = [];

            if (Array.isArray(term))
                this.__filters__ = this.__filters__.concat(term.map(t => this.validator.parse(t)));
            else
                this.__filters__.push(this.validator.parse(term));

        }

        /**
            Returns true if the identifier matches a predefined filter pattern, which is evaluated by this.parser. If a 
            parser was not present the ModelContainers schema, then the function will return true upon every evaluation.
        */
        __filterIdentifier__(identifier, filters) {
            if (filters.length > 0) {
                return this.validator.filter(identifier, filters);
            }
            return true;
        }

        _gIf_(item, term) {
            let t = this._gI_(item, this.filters);
        }

        /**
            Returns the Identifier property value if it exists in the item. If an array value for filters is passed, then undefined is returned if the identifier value does not pass filtering criteria.
            @param {(Object|Model)} item
            @param {Array} filters - An array of filter terms to test whether the identifier meets the criteria to be handled by the ModelContainerBase.
        */
        _gI_(item, filters = null) {

            let identifier = null;

            if (typeof(item) == "object" && this.key)
                identifier = item[this.key];
            else
                identifier = item;

            if (identifier && this.validator)
                identifier = this.validator.parse(identifier);

            if (filters && identifier)
                return (this.__filterIdentifier__(identifier, filters)) ? identifier : undefined;

            return identifier;
        }

        /** 
            OVERRIDE SECTION ********************************************************************
            
            All of these functions should be overridden by inheriting classes
        */

        __insert__() { return this; }

        __get__(item, __return_data__) { return __return_data__; }

        __getAll__(__return_data__) { return __return_data__; }

        __removeAll__() { return []; }

        __remove__() { return []; }

        clone() {
            let clone = super.clone();
            clone.key = this.key;
            clone.model = this.model;
            clone.validator = this.validator;
            clone.first_link = this.first_link;
            return clone;
        }

        // END OVERRIDE *************************************************************************
    }

    const proto = ModelContainerBase.prototype;
    _SealedProperty_(proto, "model", null);
    _SealedProperty_(proto, "key", "");
    _SealedProperty_(proto, "validator", null);

    class MultiIndexedContainer extends ModelContainerBase {

        constructor(data = [], root = null, address = []) {

            super(root, address);

            this.secondary_indexes = {};
            this.primary_index = null;
            this.primary_key = "";

            if (data[0] && data[0].key) {

                let key = data[0].key;

                if (data[0].model)
                    this.model = data[0].model;

                if (Array.isArray(key))
                    key.forEach((k) => (this.addKey(k)));

                data = data.slice(1);
            }

            if (Array.isArray(data) && data.length > 0)
                this.insert(data);
        }

        /**
            Returns the length of the first index in this container. 
        */
        get length() { return this.primary_index.length; }

        /**
            Insert a new ModelContainerBase into the index through the key.  
        */
        addKey(key) {
            let name = key.name;

            let container = new MultiIndexedContainer.array([{ key, model: this.model }]);

            if (this.primary_index) {
                this.secondary_indexes[name] = container;
                this.secondary_indexes[name].insert(this.primary_index.__getAll__());
            } else {
                this.primary_key = name;
                this.primary_index = container;
            }
        }

        get(item, __return_data__) {

            item = this.getHook("query", item);

            if (item) {
                for (let name in item) {
                    if (name == this.primary_key)
                        return this.primary_index.get(item[name], __return_data__);

                    else if (this.secondary_indexes[name])
                        return this.secondary_indexes[name].get(item[name], __return_data__);

                }
            } else
                return this.primary_index.get(null, __return_data__);
        }

        __insert__(model, add_list, identifier) {

            let out = false;

            model.par = this;

            if ((out = this.primary_index.insert(model))) {
                for (let name in this.secondary_indexes) {

                    let index = this.secondary_indexes[name];

                    index.insert(model);
                }
            }

            if (out)
                this.updateViews(this.primary_index.get());

            return out;
        }
        /**
            @private 
        */
        __remove__(term, out_container) {

            let out = false;

            if ((out = this.primary_index.__remove__(term, out_container))) {

                for (let name in this.secondary_indexes) {

                    let index = this.secondary_indexes[name];

                    index.__remove__(out_container);
                }
            }

            return out;
        }

        __removeAll__() {

            let out = false;

            out = this.primary_index.__removeAll__(term, out_container);

            for (let name in this.secondary_indexes) {

                let index = this.secondary_indexes[name];

                if (index.__removeAll__(model))
                    out = true;
            }

            return out;
        }


        /**
            Overrides Model container default _gI_ to force item to pass.
            @private 
        */
        _gI_(item, filters = null) {
            return true;
        }

        toJSON() {
            return this.primary_index.toJSON();
        }

        clone() {
            let clone = super.clone();
            clone.secondary_indexes = this.secondary_indexes;
            clone.primary_index = this.primary_index;
            return clone;
        }
    }

    class NumberSchemeConstructor extends SchemeConstructor {

        constructor() {

            super();

            this.start_value = 0;
        }

        parse(value) {

            return parseFloat(value);
        }

        verify(value, result) {

            result.valid = true;

            if (value == NaN || value == undefined) {
                result.valid = false;
                result.reason = "Invalid number type.";
            }
        }

        filter(identifier, filters) {

            for (let i = 0, l = filters.length; i < l; i++)
                if (identifier == filters[i])
                    return true;

            return false;
        }
    }

    let number = new NumberSchemeConstructor();

    const HORIZONTAL_TAB = 9;
    const SPACE = 32;

    /** @lends module:wick~internals */

    /**
     * The types object bound to Lexer#types
     * @type       {Object}
     * @alias module:wick~internals.lexer.Types
     * @see {@link module:wick.core.common.Lexer}
     */
    const number$1 = 1,
        identifier = 2,
        string = 4,
        white_space = 8,
        open_bracket = 16,
        close_bracket = 32,
        operator = 64,
        symbol = 128,
        new_line = 256,
        white_space_new_line = (white_space | new_line),
        Types = {
            num: number$1,
            number: number$1,
            id: identifier,
            identifier,
            str: string,
            string,
            ws: white_space,
            white_space,
            ob: open_bracket,
            open_bracket,
            cb: close_bracket,
            close_bracket,
            op: operator,
            operator,
            sym: symbol,
            symbol,
            nl: new_line,
            new_line
        };

    /**
     * Lexer Jump table reference 
     * 0. NUMBER
     * 1. IDENTIFIER
     * 2. QUOTE STRING
     * 3. SPACE SET
     * 4. TAB SET
     * 5. CARIAGE RETURN
     * 6. LINEFEED
     * 7. SYMBOL
     * 8. OPERATOR
     * 9. OPEN BRACKET
     * 10. CLOSE BRACKET 
     */
    const jump_table = [7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 6, 7, 7, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3, 8, 2, 7, 7, 8, 8, 2, 9, 10, 8, 8, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 8, 8, 8, 7, 7, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 7, 10, 7, 7, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 7, 10, 7, 7];

    /**
     * LExer Number and Identifier jump table reference
     * Number are masked by 12(4|8) and Identifiers are masked by 10(2|8)
     * entries marked as `0` are not evaluated as either being in the number set or the identifier set.
     * entries marked as `2` are in the identifier set but not the number set
     * entries marked as `4` are in the number set but not the identifier set
     * entries marked as `8` are in both number and identifier sets
     */
    const num_id = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 2, 8, 2, 2, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 2, 2, 2, 2, 2, 2, 2, 2, 8, 2, 2, 0, 0, 0, 0, 2, 0, 2, 8, 2, 2, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 2, 2, 2, 2, 2, 2, 2, 2, 8, 2, 2, 0, 0, 0, 0, 0];




    /**
     * @classdesc A simple Lexical tokenizer for use with text processing. 
     * 
     * The Lexer parses an input string and yield lexical tokens.  It also provides methods for looking ahead and asserting token values. 
     *
     * There are 9 types of tokens that the Lexer will create:
     * 
     * > 1. **Identifier** - `types.identifier` or `types.id`
     * >    - Any set of characters beginning with `_`|`a-z`|`A-Z`, and followed by `0-9`|`a-z`|`A-Z`|`-`|`_`|`#`|`$`.
     * > 2. **Number** - `types.number` or `types.num`
     * >    - Any set of characters beginning with `0-9`|`.`, and followed by `0-9`|`.`.
     * > 3. **String**: 2 - `types.string` or `types.str`
     * >    - A set of characters beginning with either `'` or `"` and ending with a matching `'` or `"`.
     * > 4. **Open Bracket** - `types.open_bracket` or `types.ob`
     * >    - A single character from the set `<`|`(`|`{`|`[`.
     * > 5. **Close Bracket** - `types.close_bracket` or `types.cb`
     * >    - A single character from the set `>`|`)`|`}`|`]`.
     * > 7. **Operator**: 
     * >    - A single character from the set `*`|`+`|`<`|`=`|`>`|`\`|`&`|`%`|`!`|`|`|`^`|`:`.
     * > 8. **New Line**: 
     * >    - A single `newline` (`LF` or `NL`) character. It may also be `LFCR` if the text is formated for Windows.
     * > 9. **White Space**: 
     * >    - An uninterrupted set of `tab` or `space` characters.
     * > 10. **Symbol**:
     * >        - All other characters not defined by the the above, with each symbol token being comprised of one character.
     * 
     * Types are identified by a binary index value and are defined in Lexer.prototype.types. A token's type can be verified by with 
     * ```js
     * Lexer.token.type === Lexer.types.*`
     * ```
     * @alias Lexer
     * @memberof module:wick.core.common
     * @param {String} string - The string to parse. 
     * @param {Boolean} [IGNORE_WHITE_SPACE=true] - If set to true, the Lexer will not generate tokens for newline and whitespace characters, and instead skip to the next no whitespace/newline token. 
     * @throws     {Error} Throws "String value must be passed to Lexer" if a non-string value is passed as `string`.
     */
    class Lexer {

        constructor(string = "", IGNORE_WHITE_SPACE = true, PEEKING = false) {

            if (typeof(string) !== "string") throw new Error("String value must be passed to Lexer");

            /**
             * The string that the Lexer tokenizes.
             */
            this.str = string;

            /**
             * Flag to ignore white spaced.
             */
            this.IWS = IGNORE_WHITE_SPACE;

            /**
             * The type id of the current token.
             */
            this.type = -1;

            /**
             * The offset in the string of the start of the current token.
             */
            this.off = 0;

            /**
             * The length of the current token.
             */
            this.tl = 0;

            /**
             * The character offset of the current token within a line.
             */
            this.char = 0;

            /**
             * The line position of the current token.
             */
            this.line = 0;

            /**
             * Flag set to true if the end of the string is met.
             */
            this.END = false;

            /**
             * Reference to the peeking Lexer.
             */
            this.p = null;

            /**
             * The length of the string being parsed
             */
            this.sl = string.length;

            /**
             * Reference to token id types.
             */
            this.types = Types;

            if (!PEEKING) this.next();
        }

        /**
         * Restricts max parse distance to the other Lexer's current position.
         * @param      {Lexer}  Lexer   The Lexer to limit parse distance by.
         */
        fence(lexer = this) {
            if (lexer.str !== this.str)
                return;
            this.sl = lexer.off;
            return this;
        }

        /**
         * Copies the Lexer.
         * @return     {Lexer}  Returns a new Lexer instance with the same property values.
         */
        copy() {
            let out = new Lexer(this.str, this.IWS, true);
            out.type = this.type;
            out.off = this.off;
            out.tl = this.tl;
            out.char = this.char;
            out.line = this.line;
            out.sl = this.sl;
            out.END = this.END;
            return out;
        }

        /**
         * Given another Lexer with the same `str` property value, it will copy the state of that Lexer.
         * @param      {Lexer}  [marker=this.peek]  The Lexer to clone the state from. 
         * @throws     {Error} Throws an error if the Lexers reference different strings.
         * @public
         */
        sync(marker = this.p) {

            if (marker instanceof Lexer) {
                if (marker.str !== this.str) throw new Error("Cannot sync Lexers with different strings!");
                this.type = marker.type;
                this.off = marker.off;
                this.tl = marker.tl;
                this.char = marker.char;
                this.line = marker.line;
                this.END = marker.END;
            }

            return this;
        }

        /**
         * Will throw a new Error, appending the parsed string line and position information to the the error message passed into the function.
         * @instance
         * @public
         * @param {String} message - The error message.
         */
        throw (message) {
            let t$$1 = ("________________________________________________"),
                n$$1 = "\n",
                is_iws = (!this.IWS) ? "\n The Lexer produced whitespace tokens" : "";
            this.IWS = false;
            let pk = this.copy();
            while (!pk.END && pk.ty !== Types.nl) { pk.n(); }
            let end = pk.off;
            throw new Error(message + "at " + this.line + ":" + this.char + n$$1 + t$$1 + n$$1 + this.str.slice(this.off - this.char, end) + n$$1 + ("").padStart(this.char - 2) + "^" + n$$1 + t$$1 + is_iws);
        }

        /**
         * Proxy for Lexer.prototype.reset
         * @public
         */
        r() { return this.reset(); }

        /**
         * Restore the Lexer back to it's initial state.
         * @public
         */
        reset() {

            this.p = null;
            this.type = -1;
            this.off = 0;
            this.tl = 0;
            this.char = 0;
            this.line = 0;
            this.END = false;

            this.n();

            return this;
        }

        /**
         * Proxy for Lexer.prototype.next
         * @public
         */
        n() { return this.next(); }

        /**
         * Sets the internal state to point to the next token. Sets Lexer.prototype.END to `true` if the end of the string is hit.
         * @public
         * @param {Lexer} [marker=this] - If another Lexer is passed into this method, it will advance the token state of that Lexer.
         */
        next(marker = this) {

            let str = marker.str;

            if (marker.sl < 1) {
                marker.off = -1;
                marker.type = -1;
                marker.tl = 0;
                marker.END = true;
                return marker;
            }

            //Token builder
            let length = marker.tl;
            let off = marker.off + length;
            let l$$1 = marker.sl;
            let IWS = marker.IWS;
            let type = symbol;
            let char = marker.char + length;
            let line = marker.line;
            let base = off;

            if (off >= l$$1) {

                marker.END = true;
                length = 0;
                base = l$$1;
                char -= base - off;

                marker.type = type;
                marker.off = base;
                marker.tl = length;
                marker.char = char;
                marker.line = line;

                return marker;
            }

            while (true) {

                base = off;

                length = 1;

                let code = str.charCodeAt(off);

                if (code < 128) {

                    switch (jump_table[code]) {
                        case 0: //NUMBER
                            while (++off < l$$1 && (12 & num_id[str.charCodeAt(off)])) {}
                            type = number$1;
                            length = off - base;
                            break;
                        case 1: //IDENTIFIER
                            while (++off < l$$1 && (10 & num_id[str.charCodeAt(off)])) {}
                            type = identifier;
                            length = off - base;
                            break;
                        case 2: //QUOTED STRING
                            while (++off < l$$1 && str.charCodeAt(off) !== code) {}
                            type = string;
                            length = off - base + 1;
                            break;
                        case 3: //SPACE SET
                            while (++off < l$$1 && str.charCodeAt(off) === SPACE) {}
                            type = white_space;
                            length = off - base;
                            break;
                        case 4: //TAB SET
                            while (++off < l$$1 && str[off] === HORIZONTAL_TAB) {}
                            type = white_space;
                            length = off - base;
                            break;
                        case 5: //CARIAGE RETURN
                            length = 2;
                        case 6: //LINEFEED
                            type = new_line;
                            char = 0;
                            line++;
                            off += length;
                            break;
                        case 7: //SYMBOL
                            type = symbol;
                            break;
                        case 8: //OPERATOR
                            type = operator;
                            break;
                        case 9: //OPEN BRACKET
                            type = open_bracket;
                            break;
                        case 10: //CLOSE BRACKET
                            type = close_bracket;
                            break;
                    }
                }

                if (IWS && (type & white_space_new_line)) {
                    if (off < l$$1) {
                        char += length;
                        type = symbol;
                        continue;
                    } else {
                        length = 0;
                        base = l$$1;
                        char -= base - off;
                        marker.END = true;
                    }
                }

                break;
            }

            marker.type = type;
            marker.off = base;
            marker.tl = length;
            marker.char = char;
            marker.line = line;

            return marker;
        }

        /**
         * Proxy for Lexer.prototype.assert
         * @public
         */
        a(text) {
            if (this.off < 0) this.throw(`Expecting ${text} got null`);

            if (this.text == text)
                this.next();
            else
                this.throw(`Expecting "${text}" got "${this.text}"`);

            return this;
        }

        /**
         * Compares the string value of the current token to the value passed in. Advances to next token if the two are equal.
         * @public
         * @throws {Error} - `Expecting "${text}" got "${this.text}"`
         * @param {String} text - The string to compare.
         */
        assert(text) {

            if (this.off < 0) this.throw(`Expecting ${text} got null`);

            if (this.text == text)
                this.next();
            else
                this.throw(`Expecting "${text}" got "${this.text}"`);

            return this;
        }

        /**
         * Proxy for Lexer.prototype.assertChcatever
         * @public
         */
        _appendChild_(text) { return this.assert(text); }
        /**
         * Compares the character value of the current token to the value passed in. Advances to next token if the two are equal.
         * @public
         * @throws {Error} - `Expecting "${text}" got "${this.text}"`
         * @param {String} text - The string to compare.
         */
        assertCharacer(char) {

            if (this.off < 0) this.throw(`Expecting ${text} got null`);

            if (this.tx[this.off] == char)
                this.next();
            else
                this.throw(`Expecting "${char}" got "${this.tx}"`);

            return this;
        }

        /**
         * Proxy for Lexer.prototype.peek
         * @public
         * @readonly
         * @type {Lexer}
         */
        get pk() { return this.peek(); }

        /**
         * Returns the Lexer bound to Lexer.prototype.p, or creates and binds a new Lexer to Lexer.prototype.p. Advences the other Lexer to the token ahead of the calling Lexer.
         * @public
         * @type {Lexer}
         * @param {Lexer} [marker=this] - The marker to originate the peek from. 
         * @param {Lexer} [peek_marker=this.p] - The Lexer to set to the next token state.
         * @return {Lexer} - The Lexer that contains the peeked at token.
         */
        peek(marker = this, peek_marker = this.p) {

            if (!peek_marker) {
                if (!marker) return null;
                if (!this.p) {
                    this.p = new Lexer(this.str, this.IWS, true);
                    peek_marker = this.p;
                }
            }

            peek_marker.type = marker.type;
            peek_marker.off = marker.off;
            peek_marker.tl = marker.tl;
            peek_marker.char = marker.char;
            peek_marker.line = marker.line;
            this.next(peek_marker);
            return peek_marker;
        }

        /**
         * Proxy for Lexer.prototype.text
         * @public
         * @type {String}
         * @readonly
         */
        get tx() { return this.text; }
        /**
         * The string value of the current token.
         * @type {String}
         * @public
         * @readonly
         */
        get text() {
            return (this.off < 0) ? "" : this.str.slice(this.off, this.off + this.tl);
        }

        /**
         * The type id of the current token.
         * @type {Number}
         * @public
         * @readonly
         */
        get ty() { return this.type; }

        /**
         * The current token's offset position from the start of the string.
         * @type {Number}
         * @public
         * @readonly
         */
        get pos() {
            return this.off;
        }

        /**
         * Proxy for Lexer.prototype.slice
         * @public
         */
        s(start) { return this.slice(start); }

        /**
         * Returns a slice of the parsed string beginning at `start` and ending at the current token.
         * @param {Number | LexerBeta} start - The offset in this.str to begin the slice. If this value is a LexerBeta, sets the start point to the value of start.off.
         * @return {String} A substring of the parsed string.
         * @public
         */
        slice(start) {

            if (typeof start === "number" || typeof start === "object") {
                if (start instanceof Lexer) start = start.off;
                return (this.END) ? this.str.slice(start, this.sl) : this.str.slice(start, this.off);
            }

            return this.str.slice(this.off, this.sl);
        }

        get ch() {
            return this.str[this.off];
        }

        /**
         * The current token in the form of a new Lexer with the current state.
         * Proxy property for Lexer.prototyp.copy
         * @type {Lexer}
         * @public
         * @readonly
         */
        get token() {
            return this.copy();
        }
        /**
         * Skips to the end of a comment section
         * @param {boolean} ASSERT - If set to true, will through an error if there is not a comment line or block to skip.
         * @param {Lexer} [marker=this] - If another Lexer is passed into this method, it will advance the token state of that Lexer.
         */
        comment(ASSERT = false, marker = this) {

            if (!(marker instanceof Lexer)) return marker;

            if (marker.tx == "/") {
                if (marker.pk.tx == "*") {
                    marker.sync();
                    while (!marker.END && (marker.n().tx != "*" || marker.pk.tx != "/")) { /* NO OP */ }
                    marker.sync().a("/");
                } else if (marker.pk.tx == "/") {
                    let IWS = marker.IWS;
                    while (marker.n().ty != types.new_line && !marker.END) { /* NO OP */ }
                    marker.IWS = IWS;
                    marker.n();
                } else
                if (ASSERT) marker.throw("Expecting the start of a comment");
            }

            return marker;
        }
    }

    Lexer.prototype.types = Types;

    class Point2D extends Float64Array{
    	
    	constructor(x, y) {
    		super(2);

    		if (typeof(x) == "number") {
    			this[0] = x;
    			this[1] = y;
    			return;
    		}

    		if (x instanceof Array) {
    			this[0] = x[0];
    			this[1] = x[1];
    		}
    	}

    	draw(ctx, s = 1){
    		ctx.beginPath();
    		ctx.moveTo(this.x*s,this.y*s);
    		ctx.arc(this.x*s, this.y*s, s*0.01, 0, 2*Math.PI);
    		ctx.stroke();
    	}

    	get x (){ return this[0]}
    	set x (v){if(typeof(v) !== "number") return; this[0] = v;}

    	get y (){ return this[1]}
    	set y (v){if(typeof(v) !== "number") return; this[1] = v;}
    }

    function posOnCurve(t, p1, p2, p3) {
        var ti = 1 - t;
        return ti * ti * p1 + 2 * ti * t * p2 + t * t * p3;
    }

    function splitCurve(bp, t) {
        var left = [];
        var right = [];

        function drawCurve(bp, t) {
            if (bp.length == 2) {
                left.push(bp[0], bp[1]);
                right.push(bp[0], bp[1]);
            } else {
                var new_bp = []; //bp.slice(0,-2);
                for (var i = 0; i < bp.length - 2; i += 2) {
                    if (i == 0) {
                        left.push(bp[i], bp[i + 1]);
                    }
                    if (i == bp.length - 4) {
                        right.push(bp[i + 2], bp[i + 3]);
                    }
                    new_bp.push((1 - t) * bp[i] + t * bp[i + 2]);
                    new_bp.push((1 - t) * bp[i + 1] + t * bp[i + 3]);
                }
                drawCurve(new_bp, t);
            }
        }

        drawCurve(bp, t);

        return {
            x: new QBezier(right),
            y: new QBezier(left)
        };
    }

    function curveIntersections(p1, p2, p3) {
        var intersections = {
            a: Infinity,
            b: Infinity
        };

        var a = p1 - 2 * p2 + p3;

        var b = 2 * (p2 - p1);

        var c = p1;

        if (b == 0) ; else if (Math.abs(a) < 0.00000000005) {
            intersections.a = (-c / b); //c / b;
        } else {

            intersections.a = ((-b - Math.sqrt((b * b) - 4 * a * c)) / (2 * a));
            intersections.b = ((-b + Math.sqrt((b * b) - 4 * a * c)) / (2 * a));
        }
        return intersections
    }

    class QBezier {
        constructor(x1, y1, x2, y2, x3, y3) {
            this.x1 = 0;
            this.x2 = 0;
            this.x3 = 0;
            this.y1 = 0;
            this.y2 = 0;
            this.y3 = 0;

            if (typeof(x1) == "number") {
                this.x1 = x1;
                this.x2 = x2;
                this.x3 = x3;
                this.y1 = y1;
                this.y2 = y2;
                this.y3 = y3;
                return;
            }

            if (x1 instanceof QBezier) {
                this.x1 = x1.x1;
                this.x2 = x1.x2;
                this.x3 = x1.x3;
                this.y1 = x1.y1;
                this.y2 = x1.y2;
                this.y3 = x1.y3;
                return;
            }

            if (x1 instanceof Array) {
                this.x1 = x1[0];
                this.y1 = x1[1];
                this.x2 = x1[2];
                this.y2 = x1[3];
                this.x3 = x1[4];
                this.y3 = x1[5];
                return;
            }
        }

        reverse() {
            return new QBezier(
                this.x3,
                this.y3,
                this.x2,
                this.y2,
                this.x1,
                this.y1
            )
        }

        point(t) {
            return new Point2D(
                posOnCurve(t, this.x1, this.x2, this.x3),
                posOnCurve(t, this.y1, this.y2, this.y3))

        }

        tangent(t) {
            var tan = {
                x: 0,
                y: 0
            };

            var px1 = this.x2 - this.x1;
            var py1 = this.y2 - this.y1;

            var px2 = this.x3 - this.x2;
            var py2 = this.y3 - this.y2;

            tan.x = (1 - t) * px1 + t * px2;
            tan.y = (1 - t) * py1 + t * py2;

            return tan;
        }

        toArray() {
            return [this.x1, this.y1, this.x2, this.y2, this.x3, this.y3];
        }

        split(t) {
            return splitCurve(this.toArray(), t);
        }

        rootsX() {
            return this.roots(
                this.x1,
                this.x2,
                this.x3
            )

        }

        roots(p1, p2, p3) {
            var curve = this.toArray();

            var c = p1 - (2 * p2) + p3;
            var b = 2 * (p2 - p1);
            var a = p1;
            var a2 = a * 2;
            var sqrt = Math.sqrt(b * b - (a * 4 * c));
            var t1 = (-b + sqrt) / a2;
            var t2 = (-b - sqrt) / a2;

            return [t1, t2];
        }

        rootsa() {
            var curve = this.toArray();

            var p1 = curve[1];
            var p2 = curve[3];
            var p3 = curve[5];
            var x1 = curve[0];
            var x2 = curve[2];
            var x3 = curve[4];

            var py1d = 2 * (p2 - p1);
            var py2d = 2 * (p3 - p2);
            var ad1 = -py1d + py2d;
            var bd1 = py1d;

            var px1d = 2 * (x2 - x1);
            var px2d = 2 * (x3 - x2);
            var ad2 = -px1d + px2d;
            var bd2 = px1d;

            var t1 = -bd1 / ad1;
            var t2 = -bd2 / ad2;

            return [t1, t2];
        }

        boundingBox() {
            var x1 = curve[0];
            var y1 = curve[1];
            var x2 = curve[2];
            var y2 = curve[3];
            var x3 = curve[4];
            var y3 = curve[5];
            var roots = getRootsClamped(curve);
            var min_x = Math.min(x1, x2, x3, roots.y[0] || Infinity, roots.x[0] || Infinity);
            var min_y = Math.min(y1, y2, y3, roots.y[1] || Infinity, roots.x[1] || Infinity);
            var max_x = Math.max(x1, x2, x3, roots.y[0] || -Infinity, roots.x[0] || -Infinity);
            var max_y = Math.max(y1, y2, y3, roots.y[1] || -Infinity, roots.x[1] || -Infinity);

            return {
                min: {
                    x: min_x,
                    y: min_y
                },
                max: {
                    x: max_x,
                    y: max_y
                }
            };
        }

        rotate(angle, offset) {
            angle = (angle / 180) * Math.PI;

            var new_curve = this.toArray();

            for (var i = 0; i < 6; i += 2) {
                var x = curve[i] - offset.x;
                var y = curve[i + 1] - offset.y;
                new_curve[i] = ((x * Math.cos(angle) - y * Math.sin(angle))) + offset.x;
                new_curve[i + 1] = ((x * Math.sin(angle) + y * Math.cos(angle))) + offset.y;
            }

            return new QBezier(new_curve);
        }

        intersects() {
            return {
                x: curveIntersections(this.x1, this.x2, this.x3),
                y: curveIntersections(this.y1, this.y2, this.y3)
            }
        }

        add(x, y) {
            if (typeof(x) == "number") {
                return new QBezier(
                    this.x1 + x,
                    this.y1 + y,
                    this.x2 + x,
                    this.y2 + y,
                    this.x3 + x,
                    this.y3 + y,
                )
            }
        }
    }

    const sqrt = Math.sqrt;
    const cos = Math.cos;
    const acos = Math.acos;
    const PI = Math.PI;
    const pow = Math.pow;

    // A real-cuberoots-only function:
    function cuberoot(v) {
      if(v<0) return -pow(-v,1/3);
      return pow(v,1/3);
    }



    function point(t, p1, p2, p3, p4) {
    	var ti = 1 - t;
    	var ti2 = ti * ti;
    	var t2 = t * t;

    	return ti * ti2 * p1 + 3 * ti2 * t * p2 + t2 * 3 * ti * p3 + t2 * t * p4;
    }


    class CBezier extends Float64Array{
    	constructor(x1, y1, x2, y2, x3, y3, x4, y4) {
    		super(8);

    		//Map P1 and P2 to {0,0,1,1} if only four arguments are provided; for use with animations
    		if(arguments.length == 4){
    			this[0] = 0;
    			this[1] = 0;
    			this[2] = x1;
    			this[3] = y1;
    			this[4] = x2;
    			this[5] = y2;
    			this[6] = 1;
    			this[7] = 1;
    			return;
    		}
    		
    		if (typeof(x1) == "number") {
    			this[0] = x1;
    			this[1] = y1;
    			this[2] = x2;
    			this[3] = y2;
    			this[4] = x3;
    			this[5] = y3;
    			this[6] = x4;
    			this[7] = y4;
    			return;
    		}

    		if (x1 instanceof Array) {
    			this[0] = x1[0];
    			this[1] = x1[1];
    			this[2] = x1[2];
    			this[3] = x1[3];
    			this[4] = x1[4];
    			this[5] = x1[5];
    			this[6] = x1[6];
    			this[7] = x1[4];
    			return;
    		}
    	}

    	get x1 (){ return this[0]}
    	set x1 (v){this[0] = v;}
    	get x2 (){ return this[2]}
    	set x2 (v){this[2] = v;}
    	get x3 (){ return this[4]}
    	set x3 (v){this[4] = v;}
    	get x4 (){ return this[6]}
    	set x4 (v){this[6] = v;}
    	get y1 (){ return this[1]}
    	set y1 (v){this[1] = v;}
    	get y2 (){ return this[3]}
    	set y2 (v){this[3] = v;}
    	get y3 (){ return this[5]}
    	set y3 (v){this[5] = v;}
    	get y4 (){ return this[7]}
    	set y4 (v){this[7] = v;}

    	add(x,y = 0){
    		return new CCurve(
    			this[0] + x,
    			this[1] + y,
    			this[2] + x,
    			this[3] + y,
    			this[4] + x,
    			this[5] + y,
    			this[6] + x,
    			this[7] + y
    		)
    	}

    	valY(t){
    		return point(t, this[1], this[3], this[5], this[7]);
    	}

    	valX(t){
    		return point(t, this[0], this[2], this[4], this[6]);
    	}

    	point(t) {
    		return new Point2D(
    			point(t, this[0], this[2], this[4], this[6]),
    			point(t, this[1], this[3], this[5], this[7])
    		)
    	}
    	
    	/** 
    		Acquired from : https://pomax.github.io/bezierinfo/
    		Author:  Mike "Pomax" Kamermans
    		GitHub: https://github.com/Pomax/
    	*/

    	roots(p1,p2,p3,p4) {
    		var d = (-p1 + 3 * p2 - 3 * p3 + p4),
    			a = (3 * p1 - 6 * p2 + 3 * p3) / d,
    			b = (-3 * p1 + 3 * p2) / d,
    			c = p1 / d;

    		var p = (3 * b - a * a) / 3,
    			p3 = p / 3,
    			q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,
    			q2 = q / 2,
    			discriminant = q2 * q2 + p3 * p3 * p3;

    		// and some variables we're going to use later on:
    		var u1, v1, root1, root2, root3;

    		// three possible real roots:
    		if (discriminant < 0) {
    			var mp3 = -p / 3,
    				mp33 = mp3 * mp3 * mp3,
    				r = sqrt(mp33),
    				t = -q / (2 * r),
    				cosphi = t < -1 ? -1 : t > 1 ? 1 : t,
    				phi = acos(cosphi),
    				crtr = cuberoot(r),
    				t1 = 2 * crtr;
    			root1 = t1 * cos(phi / 3) - a / 3;
    			root2 = t1 * cos((phi + 2 * PI) / 3) - a / 3;
    			root3 = t1 * cos((phi + 4 * PI) / 3) - a / 3;
    			return [root3, root1, root2]
    		}

    		// three real roots, but two of them are equal:
    		if (discriminant === 0) {
    			u1 = q2 < 0 ? cuberoot(-q2) : -cuberoot(q2);
    			root1 = 2 * u1 - a / 3;
    			root2 = -u1 - a / 3;
    			return [root2, root1]
    		}

    		// one real root, two complex roots
    		var sd = sqrt(discriminant);
    		u1 = cuberoot(sd - q2);
    		v1 = cuberoot(sd + q2);
    		root1 = u1 - v1 - a / 3;
    		return [root1]
    	}

    	rootsY() {
    		return this.roots(this[1],this[3],this[5],this[7])
    	}

    	rootsX() {
    		return this.roots(this[0],this[2],this[4],this[6])
    	}
    	
    	getYatX(x){
    		var x1 = this[0] - x, x2 = this[2] - x, x3 = this[4] - x, x4 = this[6] - x,
    			x2_3 = x2 * 3, x1_3 = x1 *3, x3_3 = x3 * 3,
    			d = (-x1 + x2_3 - x3_3 + x4), di = 1/d, i3 = 1/3,
    			a = (x1_3 - 6 * x2 + x3_3) * di,
    			b = (-x1_3 + x2_3) * di,
    			c = x1 * di,
    			p = (3 * b - a * a) * i3,
    			p3 = p * i3,
    			q = (2 * a * a * a - 9 * a * b + 27 * c) * (1/27),
    			q2 = q * 0.5,
    			discriminant = q2 * q2 + p3 * p3 * p3;

    		// and some variables we're going to use later on:
    		var u1, v1, root;

    		//Three real roots can never happen if p1(0,0) and p4(1,1);

    		// three real roots, but two of them are equal:
    		if (discriminant < 0) {
    			var mp3 = -p / 3,
    				mp33 = mp3 * mp3 * mp3,
    				r = sqrt(mp33),
    				t = -q / (2 * r),
    				cosphi = t < -1 ? -1 : t > 1 ? 1 : t,
    				phi = acos(cosphi),
    				crtr = cuberoot(r),
    				t1 = 2 * crtr;
    			root = t1 * cos((phi + 4 * PI) / 3) - a / 3;
    		}else if (discriminant === 0) {
    			u1 = q2 < 0 ? cuberoot(-q2) : -cuberoot(q2);
    			root = -u1 - a * i3;
    		}else{
    			var sd = sqrt(discriminant);
    			// one real root, two complex roots
    			u1 = cuberoot(sd - q2);
    			v1 = cuberoot(sd + q2);
    			root = u1 - v1 - a * i3;	
    		}

    		return point(root, this[1], this[3], this[5], this[7]);
    	}
    	/**
    		Given a Canvas 2D context object and scale value, strokes a cubic bezier curve.
    	*/
    	draw(ctx, s = 1){
    		ctx.beginPath();
    		ctx.moveTo(this[0]*s, this[1]*s);
    		ctx.bezierCurveTo(
    			this[2]*s, this[3]*s,
    			this[4]*s, this[5]*s,
    			this[6]*s, this[7]*s
    			);
    		ctx.stroke();
    	}
    }

    /**
    	JavaScript implementation of a touch scrolling interface using touch events
    */
    class TouchScroller {
        /** 
            Constructs a touch object around a given dom element. Functions listeners can be bound to this object using
            this addEventListener method.
        */
        constructor(element, drag = 0.02, touchid = 0) {
            
            this.origin_x = 0;
            this.origin_y = 0;
            this.velocity_x = 0;
            this.velocity_y = 0;
            this.GO = true;
            this.drag = (drag > 0) ? drag : 0.02;
            this.ele = element;

            if (!touchid instanceof Number)
                touchid = 0;

            let time_old = 0;

            let frame = (dx, dy, steps, ratio = 1) => {

                let drag_val = this.drag;

                dx -= dx * drag_val * steps * ratio;
                dy -= dy * drag_val * steps * ratio;

                let dm = Math.max(Math.abs(dy), Math.abs(dy));

                let end = !(steps > 0 && dm > 0.1 && this.GO);

                if (!end) {
                    requestAnimationFrame(() => {
                        frame(dx, dy, 1);
                    });
                }

                end = end && steps != 0;

                for (var i = 0, l = this.listeners.length; i < l; i++) {

                    if (this.listeners[i]({
                            dx,
                            dy,
                            end
                        })) {
                        this.GO = false;
                    } 
                }
            };

            this.event_b = (e) => {

                time_old = performance.now();

                var touch = e.touches[touchid];

                this.velocity_x = this.origin_x - touch.clientX;
                this.velocity_y = this.origin_y - touch.clientY;

                this.origin_x = touch.clientX;
                this.origin_y = touch.clientY;

                frame(this.velocity_x, this.velocity_y, 0, 0);
            };

            this.event_c = (e) => {

                let time_new = performance.now();

                let diff = time_new - time_old;

                let steps = Math.min(diff / 8.6666666, 1 / this.drag); // 60 FPS

                this.GO = true;

                frame(this.velocity_x, this.velocity_y, steps);

                this.velocity_x = 0;
                this.velocity_y = 0;

                window.removeEventListener("touchmove", this.event_b);
                window.removeEventListener("touchend", this.event_c);
            };

            this.event_a = (e) => {

                if(!this.GO){
                    e.preventDefualt();
                    e.stopPropagation();
                    return false;
                }

                time_old = performance.now();

                this.GO = false;

                var touch = e.touches[touchid];

                if (!touch)
                    return;

                this.origin_y = touch.clientY;
                this.origin_x = touch.clientX;

                window.addEventListener("touchmove", this.event_b);
                window.addEventListener("touchend", this.event_c);
            };

            this.ele.addEventListener("touchstart", this.event_a);

            this.listeners = [];

        }

        _destroy_() {
            this.listeners = null;
            this.ele.removeEventListener("touchstart", this.event_a);
        }



        addEventListener(callback) {
            if (callback instanceof Function) {

                for (var i = 0; i < this.listeners.length; i++) {
                    if (this.listeners[i] == callback) return
                }

                this.listeners.push(callback);
            }
        }

        removeEventListener(callback) {
            for (var i = 0; i < this.listeners.length; i++) {
                if (this.listeners[i] == callback) {
                    this.listeners.splice(i, 1);
                    return;
                }
            }
        }
    }

    /****** Global Object Extenders *************/
    //*
    Element.prototype.getWindowTop = function(){
        return (this.offsetTop + ((this.parentElement) ? this.parentElement.getWindowTop() : 0));
    };

    Element.prototype.getWindowLeft = function(){
        return (this.offsetLeft + ((this.parentElement) ? this.parentElement.getWindowLeft() : 0));
    };

    Element.prototype.getParentWindowTop = function(bool = false){
        return (((bool ? this.offsetTop : 0))+((this.parentElement) ? this.parentElement.getParentWindowTop(true) : 0));
    };

    Element.prototype.getParentWindowLeft = function(bool = false){
        return (((bool ? this.offsetLeft : 0))+((this.parentElement) ? this.parentElement.getWindowLeft(true) : 0));
    };

    Element.prototype.getStyle = function(style_name){
    	return window.getComputedStyle(this,null).getPropertyValue(style_name);
    };

    /**************** POLYFILLS ************************************/

    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String}
     */
    if (typeof Object.assign != 'function') {
      // Must be writable: true, enumerable: false, configurable: true
      Object.defineProperty(Object, "assign", {
        value: function assign(target, varArgs) { // .length of function is 2
          if (target == null) { // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
          }

          var to = Object(target);

          for (var index = 1; index < arguments.length; index++) {
            var nextSource = arguments[index];

            if (nextSource != null) { // Skip over if undefined or null
              for (var nextKey in nextSource) {
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                  to[nextKey] = nextSource[nextKey];
                }
              }
            }
          }
          return to;
        },
        writable: true,
        configurable: true
      });
    }

    var Common = /*#__PURE__*/Object.freeze({
        Lexer: Lexer,
        QBezier: QBezier,
        CBezier: CBezier,
        TouchScroller: TouchScroller
    });

    let scape_date = new Date();
    scape_date.setHours(0);
    scape_date.setMilliseconds(0);
    scape_date.setSeconds(0);
    scape_date.setTime(0);

    class DateSchemeConstructor extends NumberSchemeConstructor {

        parse(value) {

            if(!value)
                return undefined;

            if(value instanceof Date)
                return value.valueOf();

            if (!isNaN(value))
                return parseInt(value);

            let lex = new Lexer(value);

            let year = parseInt(lex.text);

            if (year) {

                scape_date.setHours(0);
                scape_date.setMilliseconds(0);
                scape_date.setSeconds(0);
                scape_date.setTime(0);

                lex.next();
                lex.next();
                let month = parseInt(lex.text) - 1;
                lex.next();
                lex.next();
                let day = parseInt(lex.text);
                scape_date.setFullYear(year);
                scape_date.setDate(day);
                scape_date.setMonth(month);

                lex.next();

                if (lex.pos > -1) {

                    let hours = parseInt(lex.text);
                    lex.next();
                    lex.next();
                    let minutes = parseInt(lex.text);

                    scape_date.setHours(hours);
                    scape_date.setMinutes(minutes);
                }

                return scape_date.valueOf();
            } else
                return (new Date(value)).valueOf();
        }

        /**
         
         */
        verify(value, result) {

            value = this.parse(value);

            super.verify(value, result);
        }

        filter(identifier, filters) {

            if (filters.length > 1) {

                for (let i = 0, l = filters.length - 1; i < l; i += 2) {
                    let start = filters[i];
                    let end = filters[i + 1];

                    if (start <= identifier && identifier <= end) {
                        return true;
                    }
                }
            }

            return false;
        }

        string(value) {
            
            return (new Date(value)) + "";
        }
    }

    let date = new DateSchemeConstructor();

    class TimeSchemeConstructor extends NumberSchemeConstructor {

        parse(value) {
            if (!isNaN(value))
                return parseInt(value);
            try {
                var hour = parseInt(value.split(":")[0]);
                var min = parseInt(value.split(":")[1].split(" ")[0]);
                if (value.split(":")[1].split(" ")[1])
                    half = (value.split(":")[1].split(" ")[1].toLowerCase() == "pm");
                else
                    half = 0;
            } catch (e) {
                var hour = 0;
                var min = 0;
                var half = 0;
            }

            return parseFloat((hour + ((half) ? 12 : 0) + (min / 60)));
        }

        verify(value, result) {
            this.parse(value);
            super.verify(value, result);
        }

        filter(identifier, filters) {
            return true
        }

        string(value) {
            return (new Date(value)) + "";
        }
    }

    let time = new TimeSchemeConstructor();

    class StringSchemeConstructor extends SchemeConstructor {
        
        constructor() {

            super();

            this.start_value = "";
        }
        parse(value) {

            return value + "";
        }

        verify(value, result) {
            result.valid = true;

            if (value === undefined) {
                result.valid = false;
                result.reason = " value is undefined";
            } else if (!value instanceof String) {
                result.valid = false;
                result.reason = " value is not a string.";
            }
        }

        filter(identifier, filters) {

            for (let i = 0, l = filters.length; i < l; i++)
                if (identifier.match(filters[i] + ""))
                    return true;

            return false;
        }
    }

    let string$1 = new StringSchemeConstructor();

    class BoolSchemeConstructor extends SchemeConstructor {

        constructor() {

            super();

            this.start_value = false;
        }

        parse(value) {

            return (value) ? true : false;
        }

        verify(value, result) {

            result.valid = true;

            if (value === undefined) {
                result.valid = false;
                result.reason = " value is undefined";
            } else if (!value instanceof Boolean) {
                result.valid = false;
                result.reason = " value is not a Boolean.";
            }
        }

        filter(identifier, filters) {

            if (value instanceof Boolean)
                return true;

            return false;
        }
    }

    let bool = new BoolSchemeConstructor();

    let schemes = { date, string: string$1, number, bool, time };

    class BTreeModelContainer extends ModelContainerBase {

        constructor(data = [], root = null, address = []) {

            super(root, address);

            this.validator = schemes.number;

            if (data[0] && data[0].key) {

                let key = data[0].key;

                if (typeof key == "object") {

                    if (key.type)
                        this.validator = (key.type instanceof NumberSchemeConstructor) ? key.type : this.validator;

                    if (key.name)
                        this.key = key.name;

                    if (key.unique_key)
                        this.unique_key = key.unique_key;
                } else
                    this.key = key;

                if (data[0].model)
                    this.model = data[0].model;

                data = data.slice(1);
            }

            this.min = 10;
            this.max = 20;
            this.size = 0;
            this.btree = null;

            if (Array.isArray(data) && data.length > 0)
                this.insert(data);
        }

        _destroy_() {
            if (this.btree)
                this.btree._destroy_();

            super._destroy_();
        }

        get length() {
            return this.size;
        }

        __insert__(model, add_list, identifier) {

            let result = {
                added: false
            };

            if (!this.btree)
                this.btree = new BtreeNode(true);

            this.btree = this.btree.insert(identifier, model, this.unique_key, this.max, true, result).newnode;

            if (add_list) add_list.push(model);

            if (result.added) {
                this.size++;
                this.__updateLinks__();
            }

            return result.added;
        }

        __get__(terms, __return_data__) {

            if(!this.btree) return __return_data__;

            if (__return_data__ instanceof BTreeModelContainer)
                return __return_data__;

            let out = [];

            for (let i = 0, l = terms.length; i < l; i++) {
                let b, a = terms[i];

                if (a instanceof ModelBase)
                    continue;

                if (i < l-1 && !(terms[i + 1] instanceof ModelBase)) {
                    b = terms[++i];
                } else
                    b = a;

                this.btree.get(a, b, out);
            }

            if (this.__filters__) {
                for (let i = 0, l = out.length; i < l; i++) {
                    let model = out[i];

                    if (this._gI_(model, this.__filters__))
                        __return_data__.push(model);
                }
            } else
                for (let i = 0, l = out.length; i < l; i++)
                    __return_data__.push(out[i]);



            return __return_data__;
        }

        __remove__(terms, out_container = []) {

            if(!this.btree) return false;

            let result = 0;

            for (let i = 0, l = terms.length; i < l; i++) {
                let b, a = terms[i];

                if ((a instanceof ModelBase)) {
                    let v = this._gI_(a);
                    let o = this.btree.remove(v, v, this.unique_key, this.unique_key ? a[this.unique_key] : "", true, this.min, out_container);
                    result += o.out;
                    this.btree = o.out_node;
                    continue;
                }

                if (i < l-1 && !(terms[i + 1] instanceof ModelBase)) {
                    b = terms[++i];
                } else
                    b = a;

                let o = this.btree.remove(a, b, "", "", true, this.min, out_container);
                result += o.out;
                this.btree = o.out_node;
            }

            if (result > 0) {
                this.size -= result;
                this.__updateLinks__();
                this.__linksRemove__(out_container);
            }


            return result !== 0;
        }

        __updateLinks__() {
            let a = this.first_link;
            while (a) {
                a.btree = this.btree;
                a = a.next;
            }
        }

        __getAll__(__return_data__) {

            if (this.__filters__) {
                this.__get__(this.__filters__, __return_data__);
            } else if (this.btree)
                this.btree.get(-Infinity, Infinity, __return_data__);

            return __return_data__;
        }

        __removeAll__() {
            if (this.btree)
                this.btree._destroy_();
            this.btree = null;
        }

        toJSON() {
            let out_data = [];

            if (this.btree) {

                this.btree.get(this.min, this.max, out_data);
            }

            return out_data;
        }

        clone() {
            let clone = super.clone();
            clone.btree = this.btree;
            return clone;
        }
    }

    class BtreeNode {
        constructor(IS_LEAF = false) {
            this.LEAF = IS_LEAF;
            this.nodes = [];
            this.keys = [];
            this.items = 0;
        }

        _destroy_() {

            this.nodes = null;
            this.keys = null;

            if (!this.LEAF) {
                for (let i = 0, l = this.nodes.length; i < l; i++)
                    this.nodes[i]._destroy_();
            }

        }

        balanceInsert(max_size, IS_ROOT = false) {
            if (this.keys.length >= max_size) {
                //need to split this up!

                let newnode = new BtreeNode(this.LEAF);

                let split = (max_size >> 1) | 0;

                let key = this.keys[split];

                let left_keys = this.keys.slice(0, split);
                let left_nodes = this.nodes.slice(0, (this.LEAF) ? split : split + 1);

                let right_keys = this.keys.slice((this.LEAF) ? split : split + 1);
                let right_nodes = this.nodes.slice((this.LEAF) ? split : split + 1);

                newnode.keys = right_keys;
                newnode.nodes = right_nodes;

                this.keys = left_keys;
                this.nodes = left_nodes;

                if (IS_ROOT) {

                    let root = new BtreeNode();

                    root.keys.push(key);
                    root.nodes.push(this, newnode);

                    return {
                        newnode: root,
                        key: key
                    };
                }

                return {
                    newnode: newnode,
                    key: key
                };
            }

            return {
                newnode: this,
                key: 0
            };
        }

        /**
            Inserts model into the tree, sorted by identifier. 
        */
        insert(identifier, model, unique_key, max_size, IS_ROOT = false, result) {

            let l = this.keys.length;

            if (!this.LEAF) {

                for (var i = 0; i < l; i++) {

                    let key = this.keys[i];

                    if (identifier < key) {
                        let node = this.nodes[i];

                        let o = node.insert(identifier, model, unique_key, max_size, false, result);
                        let keyr = o.key;
                        let newnode = o.newnode;

                        if (keyr == undefined) debugger

                        if (newnode != node) {
                            this.keys.splice(i, 0, keyr);
                            this.nodes.splice(i + 1, 0, newnode);
                        }

                        return this.balanceInsert(max_size, IS_ROOT);
                    }
                }

                let node = this.nodes[i];

                let {
                    newnode,
                    key
                } = node.insert(identifier, model, unique_key, max_size, false, result);

                if (key == undefined) debugger

                if (newnode != node) {
                    this.keys.push(key);
                    this.nodes.push(newnode);
                }

                return this.balanceInsert(max_size, IS_ROOT);

            } else {

                for (let i = 0, l = this.keys.length; i < l; i++) {
                    let key = this.keys[i];

                    if (identifier == key) {

                        if (unique_key) {
                            if (this.nodes[i][unique_key] !== model[unique_key]) { continue; }
                        } else
                            this.nodes[i] = model;

                        result.added = false;

                        return {
                            newnode: this,
                            key: identifier
                        };
                    } else if (identifier < key) {

                        this.keys.splice(i, 0, identifier);
                        this.nodes.splice(i, 0, model);

                        result.added = true;

                        return this.balanceInsert(max_size, IS_ROOT);
                    }
                }

                this.keys.push(identifier);
                this.nodes.push(model);

                result.added = true;

                return this.balanceInsert(max_size, IS_ROOT);
            }

            return {
                newnode: this,
                key: identifier,
            };
        }

        balanceRemove(index, min_size) {
            let left = this.nodes[index - 1];
            let right = this.nodes[index + 1];
            let node = this.nodes[index];

            //Left rotate
            if (left && left.keys.length > min_size) {

                let lk = left.keys.length;
                let ln = left.nodes.length;

                node.keys.unshift((node.LEAF) ? left.keys[lk - 1] : this.keys[index - 1]);
                node.nodes.unshift(left.nodes[ln - 1]);

                this.keys[index - 1] = left.keys[lk - 1];

                left.keys.length = lk - 1;
                left.nodes.length = ln - 1;

                return false;
            } else
                //Right rotate
                if (right && right.keys.length > min_size) {

                    node.keys.push((node.LEAF) ? right.keys[0] : this.keys[index]);
                    node.nodes.push(right.nodes[0]);

                    right.keys.splice(0, 1);
                    right.nodes.splice(0, 1);

                    this.keys[index] = (node.LEAF) ? right.keys[1] : right.keys[0];

                    return false;

                } else {

                    //Left or Right Merge
                    if (!left) {
                        index++;
                        left = node;
                        node = right;
                    }

                    let key = this.keys[index - 1];
                    this.keys.splice(index - 1, 1);
                    this.nodes.splice(index, 1);

                    left.nodes = left.nodes.concat(node.nodes);
                    if (!left.LEAF) left.keys.push(key);
                    left.keys = left.keys.concat(node.keys);


                    if (left.LEAF)
                        for (let i = 0; i < left.keys.length; i++)
                            if (left.keys[i] != left.nodes[i].id)
                                ;
                    return true;
                }

        }

        remove(start, end, unique_key, unique_id, IS_ROOT = false, min_size, out_container) {
            let l = this.keys.length,
                out = 0,
                out_node = this;

            if (!this.LEAF) {

                for (var i = 0; i < l; i++) {

                    let key = this.keys[i];

                    if (start <= key)
                        out += this.nodes[i].remove(start, end, unique_key, unique_id, false, min_size, out_container).out;
                }

                out += this.nodes[i].remove(start, end, unique_key, unique_id, false, min_size, out_container).out;

                for (var i = 0; i < this.nodes.length; i++) {
                    if (this.nodes[i].keys.length < min_size) {
                        if (this.balanceRemove(i, min_size)) {
                            l--;
                            i--;
                        }
                    }
                }

                if (this.nodes.length == 1)
                    out_node = this.nodes[0];

            } else {

                for (let i = 0, l = this.keys.length; i < l; i++) {
                    let key = this.keys[i];

                    if (key <= end && key >= start) {
                        if (unique_id && this.nodes[i][unique_key] !== unique_id) continue;
                        out_container.push(this.nodes[i]);
                        out++;
                        this.keys.splice(i, 1);
                        this.nodes.splice(i, 1);
                        l--;
                        i--;
                    }
                }
            }

            return {
                out_node,
                out
            };
        }

        get(start, end, out_container) {

            if (!start || !end)
                return false;

            if (!this.LEAF) {

                for (var i = 0, l = this.keys.length; i < l; i++) {

                    let key = this.keys[i];

                    if (start <= key)
                        this.nodes[i].get(start, end, out_container);
                }

                this.nodes[i].get(start, end, out_container);

            } else {

                for (let i = 0, l = this.keys.length; i < l; i++) {
                    let key = this.keys[i];

                    if (key <= end && key >= start)
                        out_container.push(this.nodes[i]);
                }
            }
        }
    }

    MultiIndexedContainer.btree = BTreeModelContainer;

    const ArrayContainerProxySettings = {

        set: function(obj, prop, val) {

            if (prop in obj && obj[prop] == val)
                return true;

            let property = obj[prop];

            if (property && typeof(property) == "object")
                property.set(val);
            else
                obj[prop] = val;

            obj.scheduleUpdate(prop);

            return true;
        },

        get: function(obj, prop, val) {

            if (prop in obj)
                return obj[prop];

            if (!isNaN(prop))
                return obj.data[prop];

            let term = {};

            term[obj.key] = prop;

            return obj.get(prop, [])[0];
        }
    };

    /**
        Stores models in random order inside an internal array object. 
     */

    class ArrayModelContainer extends ModelContainerBase {

        constructor(data = [], root = null, address = []) {

            super(root, address);

            if (data[0] && data[0].key) {

                let key = data[0].key;

                /* Custom selection of container types happens here. 
                 * If there are multiple keys present, then a MultiIndexedContainer is used.
                 * If the value of the key is a Numerical type, then a BtreeModelContainer is used.
                 **/
                if (typeof(key) == "object") {

                    if (Array.isArray(key))
                        return new MultiIndexedContainer(data, root, address);

                    if (key.type) {
                        if (key.type instanceof NumberSchemeConstructor)
                            return new BTreeModelContainer(data, root, address);
                        this.validator = (key.type instanceof SchemeConstructor) ? key.type : this.validator;
                    }

                    if (key.name)
                        this.key = key.name;
                } else
                    this.key = key;

                if (data[0].model)
                    this.model = data[0].model;

                data = data.slice(1);
            }

            this.data = [];

            if (Array.isArray(data) && data.length > 0)
                this.insert(data);
        }

        _destroy_() {

            this.data = null;

            super._destroy_();
        }

        get proxy() { return new Proxy(this, ArrayContainerProxySettings); }

        set proxy(v) {}

        get length() { return this.data.length; }

        __defaultReturn__(USE_ARRAY) {

            if (USE_ARRAY) return new MCArray();

            let n = this.clone();

            this.__link__(n);

            return n;
        }

        __insert__(model, add_list, identifier) {

            for (var i = 0, l = this.data.length; i < l; i++) {

                var obj = this.data[i];

                if (this._gI_(obj) == identifier) {

                    if (obj.MUTATION_ID !== this.MUTATION_ID) {
                        obj = obj.clone();
                        obj.MUTATION_ID = this.MUTATION_ID;
                    }

                    obj.set(model, true);

                    this.data[i] = obj;

                    return false; //Model not added to Container. Model just updated.
                }
            }

            this.data.push(model);

            model.address = this.address.slice();
            model.address.push(this.data.length - 1);

            model.root = this.root;

            if (add_list) add_list.push(model);

            return true; // Model added to Container.
        }

        getByIndex(i) {
            return this.data[i];
        }

        setByIndex(i, m) {
            this.data[i] = m;
        }

        __get__(term, return_data) {

            let terms = null;

            if (term)
                if (term instanceof Array)
                    terms = term;
                else
                    terms = [term];

            for (let i = 0, l = this.data.length; i < l; i++) {
                let obj = this.data[i];
                if (this._gI_(obj, terms)) {
                    return_data.push(obj);
                }
            }

            return return_data;
        }

        __getAll__(return_data) {

            this.data.forEach((m) => {
                return_data.push(m);
            });

            return return_data;
        }

        __removeAll__() {
            let items = this.data.map(d => d) || [];

            this.data.length = 0;

            return items;
        }

        _setThroughRoot_(data, address, index, len, m_id) {

            if (index >= len)
                return this;

            let i = address[index++];

            let model_prop = this.data[i];

            if (model_prop.MUTATION_ID !== this.MUTATION_ID) {
                model_prop = model_prop.clone();
                model_prop.MUTATION_ID = this.MUTATION_ID;
            }

            this.data[i] = model_prop;

            return model_prop._setThroughRoot_(data, address, index, len, model_prop.MUTATION_ID);
        }

        __remove__(term, out_container) {

            let result = false;

            term = term.map(t => (t instanceof ModelBase) ? this._gI_(t) : t);
            
            for (var i = 0, l = this.data.length; i < l; i++) {
                var obj = this.data[i];

                if (this._gI_(obj, term)) {

                    result = true;

                    this.data.splice(i, 1);

                    l--;
                    i--;

                    out_container.push(obj);

                    break;
                }
            }

            return result;
        }

        toJSON() { return this.data; }

        clone() {
            let clone = super.clone();
            clone.data = this.data.slice();
            return clone;
        }
    }

    MultiIndexedContainer.array = ArrayModelContainer;

    Object.freeze(ArrayModelContainer);

    class Model extends ModelBase {

        constructor(data, root = null, address = []) {

            super(root, address);

            _SealedProperty_(this, "prop_array", []);
            _SealedProperty_(this, "prop_offset", 0);
            _SealedProperty_(this, "look_up", {});

            if (data)
                for (let name in data)
                    this._createProp_(name, data[name]);

        }

        get proxy() { return this;}

        set(data, FROM_ROOT = false) {

            if (!FROM_ROOT)
                return this._deferUpdateToRoot_(data).set(data, true);

            if (!data)
                return false;

            let out = false;

            for (let prop_name in data) {

                let index = this.look_up[prop_name];

                if (index !== undefined) {

                    let prop = this.prop_array[index];

                    if (typeof(prop) == "object") {

                        if (prop.MUTATION_ID !== this.MUTATION_ID) {
                            prop = prop.clone();
                            prop.MUTATION_ID = this.MUTATION_ID;
                            this.prop_array[index] = prop;
                        }

                        if (prop.set(data[prop_name], true)){
                            this.scheduleUpdate(prop_name);
                            out = true;
                        }

                    } else if (prop !== data[prop_name]) {
                        this.prop_array[index] = data[prop_name];
                         this.scheduleUpdate(prop_name);
                         out = true;
                    }
                } else{
                    this._createProp_(prop_name, data[prop_name]);
                    out = true;
                }
            }

            return out;
        }
        _createProp_(name, value) {

            let index = this.prop_offset++;

            this.look_up[name] = index;
            var address = this.address.slice();
            address.push(index);

            switch (typeof(value)) {

                case "object":
                    if (Array.isArray(value))
                        this.prop_array.push(new ArrayModelContainer(value, this.root, address));
                    else {
                        if (value instanceof ModelBase) {
                            value.address = address;
                            this.prop_array.push(value);
                        } else
                            this.prop_array.push(new Model(value, this.root, address));
                    }

                    this.prop_array[index].prop_name = name;
                    this.prop_array[index].par = this;

                    Object.defineProperty(this, name, {

                        configurable: false,

                        enumerable: true,

                        get: function() { return this.getHook(name, this.prop_array[index]); },

                        set: (v) => {}
                    });

                    break;

                case "function":

                    let object = new value(null, this.root, address);

                    object.par = this;
                    object.prop_name = name;

                    this.prop_array.push(object);

                    Object.defineProperty(this, name, {

                        configurable: false,

                        enumerable: true,

                        get: function() { return this.getHook(name, this.prop_array[index]); },

                        set: (v) => {}
                    });

                    break;

                default:
                    this.prop_array.push(value);

                    Object.defineProperty(this, name, {

                        configurable: false,

                        enumerable: true,

                        get: function() { return this.getHook(name, this.prop_array[index]); },

                        set: function(value) {

                            let val = this.prop_array[index];

                            if (val !== value) {
                                this.prop_array[index] = this.setHook(name, value);
                                this.scheduleUpdate(name);
                            }
                        }
                    });
            }

            this.scheduleUpdate(name);
        }
    }

    ModelContainerBase.prototype.model = Model;

    class Store {
        constructor(data) {

            this.history = [{ model: new Model(data, this), actions: [{ d: data, a: null }] }];
            this.MUTATION_ID = 0;
        }

        seal() { this.MUTATION_ID++; }

        getHistory(index) { return (this.history[index]) ? this.history[index].model : null; }

        get current() { return this.history[this.history.length - 1].model; }

        set current(v) {}

        get(data){
            return this.current.get(data);
        }

        set(data){
            return this.current.set(data);
        }

        _getParentMutationID_() { return this.MUTATION_ID; }

        _setThroughRoot_(data, address, index, len_minus_1, m_id) {

            let model_prop = this.current;

            if (m_id !== this.MUTATION_ID) {

                if (m_id > this.MUTATION_ID)
                    this.MUTATION_ID = this.MUTATION_ID + 1;
                else
                    this.MUTATION_ID = this.MUTATION_ID;

                model_prop = model_prop.clone();

                model_prop.MUTATION_ID = this.MUTATION_ID;

                this.history.push({ model: model_prop, actions: [] });
            }

            if (data)
                this.history[this.history.length - 1].actions.push({ d: data, a: address });

            return model_prop._setThroughRoot_(data, address, index, len_minus_1, this.MUTATION_ID);
        }
    }

    //import { CustomComponent } from "../page/component"

    /**
     * There are a number of configurable options and global objects that can be passed to wick to be used throughout the PWA. The instances of the Presets class are objects that hosts all these global properties. 
     * 
     * Presets are designed to be created once, upfront, and not changed once defined. This reinforces a holistic design for a PWA should have in terms of the types of Schemas, global Models, and overall form the PWA takes, e.g whether to use the ShadowDOM or not.
     * 
     * Note: *This object is made immutable once created.*
     * 
     * @param      {Object | Presets}  preset_options  An Object containing configuration data to be used by Wick.
     * @memberof module:wick
     * @alias Presets
     */
    class Presets {
        constructor(preset_options = {}) {

            this.store = (preset_options.store instanceof Store) ? preset_options.store : null;
            
            /**
             * {Object} Store for optional parameters used in the app
             */
            this.options = {
                USE_SECURE:true,
                USE_SHADOW:false,
            };

            //Declaring the properties upfront to give the VM a chance to build an appropriate virtual class.
            this.components = {};

            this.custom_components = {};

            /** 
             * Store of user defined CustomSourcePackage factories that can be used in place of the components built by the Wick templating system. Accepts any class extending the CustomComponent class. Adds these classes from preset_options.custom_sources or preset_options.components. 
             * 
             * In routing mode, a HTML `<component>` tag whose first classname matches a property name of a member of presets.custom_sources will be assigned to an instance of that member.
             * 
             * ### Example
             * In HTML:
             * ```html
             * <component class="my_source class_style">
             * 
             * ```
             * In JavaScript:
             * ```javascript
             * let MySource = CustomSourcePackage( ele =>{
             *      ele.append
             * }, {});
             * 
             * preset_options.custom_componets = {
             *      my_source : MySource
             * }
             * ```
             * @instance
             * @readonly
             */
            this.custom_sources = {};

            /**
             * { Object } Store of user defined classes that extend the Model or Model classes. `<w-source>` tags in templates that have a value set for the  `schema` attribute, e.g. `<w-s schema="my_favorite_model_type">...</w-s>`, will be bound to a new instance of the class in presets.schema whose property name matches the "schema" attribute.
             * 
             * Assign classes that extend Model or SchemedModel to preset_options.schemas to have them available to Wick.
             * 
             * In JavaScript:
             * ```javascript
             * class MyFavoriteModelType extends Model {};
             * preset_options.custom_componets = {
             *      my_favorite_model_type : MyFavoriteModelType
             * }
             * ```
             * note: presets.schema.any is always assigned to the Model class.
             * @instance
             * @readonly
             */
            this.schemas = { any: Model };

            /**
             * { Object } Store of user defined Model instances that serve as global models, which are available to the whole application. Multiple Sources will be able to _bind_ to the Models. `<w-source>` tags in templates that have a value set for the  `model` attribute, e.g. `<w-s model="my_global_model">...</w-s>`, will be bound to the model in presets ._model_ whose property name matches the "model" attribute.
             * 
             * Assign instances of Model or Model or any class that extends these to preset_options.models to have them used by Wick.
             * 
             * In JavaScript:
             * ```javascript
             * const MyGlobalModel = new Model({global_data: "This is global!"});
             * preset_options.custom_componets = {
             *      my_global_model : MyGlobalModel
             * }
             * ```
             * @instance
             * @readonly
             */
            this.models = {};

            /**
             * Configured by `preset_options.USE_SHADOW`. If set to true, and if the browser supports it, compiled and rendered template elements will be bound to a `<component>` shadow DOM, instead being appended as a child node.
             * @instance
             * @readonly
             */
            this.USE_SHADOW = false;

            /**
             * { Object } Contains all user defined HTMLElement templates 
             */
            this.templates = {};

            /**
             * Custom objects that can be used throughout component scripts. User defined. 
             */
            this.custom = preset_options.custom;

            let c = preset_options.options;
            if (c)
                for (let cn in c)
                    this.options[cn] = c[cn];


            c = preset_options.components;
            if (c)
                for (let cn in c)
                    this.components[cn] = c[cn];

            c = preset_options.custom_sources;
            if (c)
                for (let cn in c)
                    if (cn instanceof CustomComponent)
                        this.custom_sources[cn] = c[cn];

            c = preset_options.custom_components;
            if (c)
                for (let cn in c)
                        this.custom_components[cn] = c[cn];

            c = preset_options.models;
            
            if (c)
                for (let cn in c)
                    if (c[cn] instanceof ModelBase)
                        this.models[cn] = c[cn];

            c = preset_options.schemas;
            if (c)
                for (let cn in c)
                    if (ModelBase.isPrototypeOf(c[cn]))
                        this.schemas[cn] = c[cn];

            this.options.USE_SHADOW = (this.options.USE_SHADOW) ? (DOC.head.createShadowRoot || DOC.head.attachShadow) : false;

            Object.freeze(this.options);
            Object.freeze(this.custom_sources);
            Object.freeze(this.schemas);
            Object.freeze(this.models);


            //Object.freeze(this);
        }

        processLink(link){}
    }

    /**
     *   This is used by Model to create custom property getter and setters on non-ModelContainerBase and non-Model properties of the Model constructor.
     *   @protected
     *   @memberof module:wick~internals.model
     */
    function CreateSchemedProperty(object, scheme, schema_name, index) {

        if (object[schema_name])
            return;

        Object.defineProperty(object, schema_name, {
            configurable: false,
            enumerable: true,
            get: function() {
                return this.getHook(schema_name, this.prop_array[index]);
            },
            set: function(value) {

                let result = { valid: false };

                let val = scheme.parse(value);

                scheme.verify(val, result);

                if (result.valid && this.prop_array[index] != val) {
                    this.prop_array[index] = this.setHook(schema_name, val);
                    this.scheduleUpdate(schema_name);
                    this._changed_ = true;
                }
            }
        });
    }

    /**
        This is used by Model to create custom property getter and setters on Model properties of the Model constructor.
        @protected
        @memberof module:wick~internals.model
    */
    function CreateModelProperty(object, model, schema_name, index) {

        Object.defineProperty(object, schema_name, {
            configurable: false,
            enumerable: true,
            get: function() {

                let m = this.prop_array[index];

                if (!m) {
                    let address = this.address.slice();
                    address.push(index);
                    m = new model(null, this.root, address);
                    m.par = this;
                    m.prop_name = schema_name;
                    m.MUTATION_ID = this.MUTATION_ID;
                    this.prop_array[index] = m;
                }

                return this.getHook(schema_name, m);
            }
        });
    }

    class SchemedModel extends ModelBase {

        constructor(data, root = null, address = [], _schema_ = null) {


            super(root, address);

            if (this.constructor === SchemedModel)
                this.constructor = (class extends SchemedModel {});

            if (!this.schema) {

                let schema = this.constructor.schema || _schema_;

                this.constructor.schema = schema;

                if (schema) {

                    let __FinalConstructor__ = schema.__FinalConstructor__;

                    let constructor = this.constructor;
                    let prototype = constructor.prototype;

                    _FrozenProperty_(prototype, "schema", schema);

                    if (!__FinalConstructor__) {
                        let count = 0;
                        let look_up = {};

                        for (let schema_name in schema) {
                            let scheme = schema[schema_name];

                            if (schema_name == "self" && Array.isArray(scheme))
                                return CreateSchemedContainer(schema, root, address);

                            if (schema_name == "getHook") {
                                prototype.getHook = scheme;
                                continue;
                            }

                            if (schema_name == "setHook") {
                                prototype.setHook = scheme;
                                continue;
                            }

                            if (schema_name == "proto") {
                                for (let name in schema.proto)
                                        prototype[name] = schema.proto[name];
                                continue;
                            }

                            if (typeof(schema) == "object") {
                                if (Array.isArray(scheme)) {
                                    if (scheme[0] && scheme[0].container && scheme[0].schema)
                                        CreateModelProperty(prototype, scheme[0], schema_name, count);
                                    else if (scheme[0] instanceof ModelContainerBase)
                                        CreateModelProperty(prototype, scheme[0].constructor, schema_name, count);
                                    else
                                        CreateModelProperty(prototype, Model, schema_name, count);
                                } else if (scheme instanceof SchemeConstructor)
                                    CreateSchemedProperty(prototype, scheme, schema_name, count);
                                else {

                                    CreateModelProperty(prototype, scheme.constructor, schema_name, count);
                                }
                            } else {
                                console.warn(`Could not create property ${schema_name}.`);

                                continue;
                            }

                            look_up[schema_name] = count;
                            count++;
                        }



                        _SealedProperty_(prototype, "prop_offset", count);
                        _SealedProperty_(prototype, "look_up", look_up);
                        _SealedProperty_(prototype, "changed", false);

                        Object.seal(constructor);

                        _FrozenProperty_(schema, "__FinalConstructor__", constructor);

                        //Start the process over with a newly minted Model that has the properties defined in the Schema
                        return new schema.__FinalConstructor__(data, root, address);
                    }
                } else
                    return new Model(data, root, address);
            }

            Object.defineProperty(this, "prop_array", { value: new Array(this.prop_offset), enumerable: false, configurable: false, writable: true });

            if (data)
                this.set(data, true);
        }

        set(data, FROM_ROOT = false) {

            if (!FROM_ROOT)
                return this._deferUpdateToRoot_(data).set(data, true);

            if (!data)
                return false;

            this._changed_ = false;
            
            for (let prop_name in data) {

                let data_prop = data[prop_name];

                let index = this.look_up[prop_name];

                if (index !== undefined) {

                    let prop = this[prop_name];

                    if (typeof(prop) == "object") {

                        if (prop.MUTATION_ID !== this.MUTATION_ID) {
                            prop = prop.clone();
                            prop.MUTATION_ID = this.MUTATION_ID;
                            this.prop_array[index] = prop;
                        }

                        if (prop.set(data_prop, true))
                            this.scheduleUpdate(prop_name);

                    } else {
                        this[prop_name] = data_prop;
                    }
                }
            }

            return this._changed_;
        }

        _destroy_() { this.root = null; }

        _createProp_() {}
    }

    function CreateSchemedContainer(schema, root, address) {
        let data = schema.self;

        let out = new ArrayModelContainer(data, root, address);

        if (schema.proto)
            for (let name in schema.proto)
                _SealedProperty_(out, name, schema.proto[name]);

        return out;
    }

    /**
     * Base class for an object that binds to and observes a Model.
     *@alias module:wick.core.view
     */
    class View{

    	constructor(){
    		/**
    		 * property
    		 */
    		this.nx = null;
    		this.pv = null;
    		this ._model_ = null;
    	}

    	/**
         * Unbinds the View from its Model and sets all properties to undefined. Should be called by any class extending View
    	 * ``` js
    	 * class ExtendingView extends wick.core.view.View{
    	 * 		_destroy_(){
    	 * 			//... do some stuff ...
    	 * 			super._destroy_();
    	 * 		}
    	 * }
    	 * ```
         * @protected
         */
    	_destroy_(){

    		if(this ._model_)
    			this ._model_.removeView(this);
    	
    		this ._model_ = undefined;
    		this.nx = undefined;
    	}	
    	/**
    		Called by a Model when its data has changed.
    	*/
    	_update_(data){

    	}
    	/**
    		Called by a ModelContainerBase when an item has been removed.
    	*/
    	removed(data){

    	}

    	/**
    		Called by a ModelContainerBase when an item has been added.
    	*/
    	added(data){

    	}
    	setModel(model){
    	}

    	reset(){
    		
    	}
    	unsetModel(){

    		this.nx = null;
    		this ._model_ = null;
    	}
    }

    class SourceManager {

        constructor(model, element) {
            this.sources = [];
            this.model = model;
            this.ele = element;
            this.index = -1;
            this._APPEND_STATE_ = false;
            this._TRANSITION_STATE_ = false;
        }

        _destroy_() {
            for (let i = 0; i < this.sources.length; i++)
                this.sources[i]._destroy_();
            this.source = null;
            this.model = null;
            this.ele = null;
        }

        emit(name, value) {
            for (let i = 0; i < this.sources.length; i++)
                this.sources[i]._upImport_(name, value, { event: {} });
        }

        _appendToDOM_(element) {
            this._APPEND_STATE_ = true;
            if (!this.ele.parentElement || (this.ele.parentElement != element))
                element.appendChild(this.ele);
        }

        _removeFromDOM_() {
            if (this._APPEND_STATE_ == true) return;

            if (this.ele.parentElement)
                this.ele.parentElement.removeChild(this.ele);
        }

        _transitionIn_() {
            if (this._TRANSITION_STATE_ === true) return;
            this._TRANSITION_STATE_ = true;
            this._APPEND_STATE_ = true;
            for (let i = 0, l = this.sources.length; i < l; i++) {

                let ast = this.sources[i].ast;

                let css = ast.css;

                let hooks = this.sources[i].hooks;

                for (let i = 0, l = hooks.length; i < l; i++) {

                    let hook = hooks[i];
                    if (!hook) continue;
                    let ele = hook.ele;

                    if (ele.getAttribute("trs") == "in") continue;

                    ele.setAttribute("trs", "in");

                    if (css) {

                        let rule = css.getApplicableRules(ele);

                        if (hook.style) {
                            hook.style._setRule_(rule);
                        } else {
                            ele.style = rule + "";
                        }
                        //debugger
                    }
                }
            }
        }

        _transitionOut_(DESTROY_ON_REMOVE) {
            if (this._TRANSITION_STATE_ === false) {
                if (DESTROY_ON_REMOVE) this._destroy_();
                return;
            }        
            this._TRANSITION_STATE_ = false;

            this._APPEND_STATE_ = false;

            let transition_time = 0;

            for (let i = 0, l = this.sources.length; i < l; i++) {

                let ast = this.sources[i].ast;

                let css = ast.css;

                let hooks = this.sources[i].hooks;

                for (let i = 0, l = hooks.length; i < l; i++) {

                    let hook = hooks[i];

                    if (!hook) continue;
                    let ele = hook.ele;

                    if (ele.getAttribute("trs") == "out") continue;
                    ele.setAttribute("trs", "out");

                    if (css) {

                        let rule = css.getApplicableRules(ele);

                        for (let name in rule.props)
                            if (name == "transition")
                                for (let i = 0, prop = rule.props[name]; i < prop.length; i++) {
                                    let sub_prop = prop[i];
                                    if (!isNaN(sub_prop))
                                        transition_time = Math.max(transition_time, sub_prop.milliseconds);

                                }

                        if (hook.style)
                            hook.style._setRule_(rule);
                        else
                            ele.style = rule + "";
                    }
                }
            }

            if (transition_time > 0)
                setTimeout(() => { this._removeFromDOM_(); if (DESTROY_ON_REMOVE) this._destroy_(); }, transition_time + 32);
            else {
                this._removeFromDOM_();
                if (DESTROY_ON_REMOVE) this._destroy_();
            }

            return transition_time;
        }

        _down_(data, changed_values) {
            for (let i = 0, l = this.sources.length; i < l; i++)
                this.sources[i]._down_(data, changed_values);
        }
    }

    // Mode Flag
    const KEEP = 0;
    const IMPORT = 1;
    const EXPORT = 2;
    const PUT = 4;

    /**
     * Gateway for data flow. Represents a single "channel" of data flow. 
     * 
     * By using different modes, one can control how data enters and exits the source context.
     * -`keep`: 
     *  This mode is the default and treats any data on the channel as coming from the model. The model itself is not changed, and any data flow from outside the source context is ignored.
     * -`put`:
     *  This mode will update the model to reflect updates on the channel.
     * -`import`:
     *  This mode will allow data from outside the source context to enter the context as if it came from the model.
     *  -`export`:
     *  This mode will propagate data flow to the outer source context, allowing other sources to listen on the data flow of the originating source context.
     *  
     *  if `import` is active, then `keep` is implicitly inactive and the model no longer has any bearing on the value of the channel.
     */
    class Tap {

        constructor(source, prop, modes = 0) {
            this._source_ = source;
            this._prop_ = prop;
            this._modes_ = modes; // 0 implies keep
            this._ios_ = [];

            if (modes & IMPORT && source.parent)
                source.parent.getTap(prop)._ios_.push(this);

        }

        _destroy_() {

            for (let i = 0, l = this._ios_.length; i < l; i++)
                this._ios_[i]._destroy_();

            this._ios_ = null;
            this._source_ = null;
            this._prop_ = null;
            this._modes_ = null;
        }

        load(data) {
            this._downS_(data);
        }

        _down_(value, meta) {
            for (let i = 0, l = this._ios_.length; i < l; i++)
                this._ios_[i]._down_(value, meta);
        }

        _downS_(model, IMPORTED = false) {
            if (IMPORTED) {
                if (!(this._modes_ & IMPORT))
                    return;
                if (this._modes_ & PUT)
                    this._source_._model_[this._prop_] = model[this._prop_];
            }

            const value = model[this._prop_];

            if (typeof(value) !== "undefined") 
                this._down_(value);
        }

        _up_(value, meta) {

            if (!(this._modes_ & (EXPORT | PUT))) 
                this._down_(value, meta);

            if (this._modes_ & PUT){
                this._source_._model_[this._prop_] = value;
            }

            if (this._modes_ & EXPORT)
                this._source_._up_(this, value, meta);



        }
    }

    class UpdateTap extends Tap {
        _downS_(model) {
            for (let i = 0, l = this._ios_.length; i < l; i++)
                this._ios_[i]._down_(model);
        }
        _up_() {}
    }

    class Source extends View {

        /**
         *   In the Wick dynamic template system, Sources serve as the primary access to Model data. They, along with {@link SourceTemplate}s, are the only types of objects the directly _bind_ to a Model. When a Model is updated, the Source will transmit the updated data to their descendants, which are comprised of {@link Tap}s and {@link SourceTemplate}s.
         *   A Source will also _bind_ to an HTML element. It has no methodes to _update_ the element, but it's descendants, primarily instances of the {@link IO} class, can _update_ attributes and values of then element and its sub-elements.
         *   @param {Source} parent - The parent {@link Source}, used internally to build a hierarchy of Sources.
         *   @param {Object} data - An object containing HTMLELement attribute values and any other values produced by the template parser.
         *   @param {Presets} presets - An instance of the {@link Presets} object.
         *   @param {HTMLElement} element - The HTMLElement the Source will _bind_ to.
         *   @memberof module:wick~internals.source
         *   @alias Source
         *   @extends SourceBase
         */
        constructor(parent, presets, element, ast) {
            super();

            this.ast = ast;
            /**
             *@type {Boolean} 
             *@protected
             */


            this.parent = parent;
            this.ele = element;
            this._presets_ = presets;
            this._model_ = null;
            this._statics_ = null;

            this.taps = {};
            this.update_tap = null;
            this.children = [];
            this.sources = [];
            this._ios_ = [];
            this._templates_ = [];
            this.hooks = [];

            this._model_name_ = "";
            this._schema_name_ = "";

            this.DESTROYED = false;
            this.LOADED = false;

            this.addToParent();
        }

        _destroy_() {

            this.DESTROYED = true;

            if (this.LOADED) {
                this.LOADED = false;
            }

            if(this.parent)
                this.parent.removeSource(this);
            //this.finalizeTransitionOut();
            this.children.forEach((c) => c._destroy_());
            this.children.length = 0;
            this.data = null;

            if (this.ele && this.ele.parentElement)
                this.ele.parentElement.removeChild(this.ele);

            this.ele = null;

            for (let i = 0, l = this.sources.length; i < l; i++)
                this.sources[i]._destroy_();


            super._destroy_();

        }

        addToParent() {
            if (this.parent)
                this.parent.sources.push(this);
        }

        addTemplate(template) {
            template.parent = this;
            this._templates_.push(template);
        }

        addSource(source) {
            if (source.parent == this)
                return;
            source.parent = this;
            this.sources.push(source);
        }

        removeSource(source) {
            if (source.parent !== this)
                return;

            for(let i = 0; i < this.sources.length; i++)
                if(this.sources[i] == source)
                    return (this.sources.splice(i,1), source.parent = null);
        }
        
        getTap(name) {
            let tap = this.taps[name];

            if (!tap) {
                if (name == "update")
                    this.update_tap = new UpdateTap(this, name);
                else
                    tap = this.taps[name] = new Tap(this, name);
            }
            return tap;
        }

        /**
         * Return an array of Tap objects that
         * match the input array.
         */

        _linkTaps_(tap_list) {
            let out_taps = [];
            for (let i = 0, l = tap_list.length; i < l; i++) {
                let tap = tap_list[i];
                let name = tap.name;
                if (this.taps[name])
                    out_taps.push(this.taps[name]);
                else {
                    let bool = name == "update";
                    let t = bool ? new UpdateTap(this, name, tap._modes_) : new Tap(this, name, tap._modes_);

                    if (bool)
                        this.update_tap = t;

                    this.taps[name] = t;
                    out_taps.push(this.taps[name]);
                }
            }

            return out_taps;
        }

        /**
            Sets up Model connection or creates a new Model from a schema.
        */
        load(model) {

            let m = this._presets_.models[this._model_name_];


            let s = this._presets_.schemas[this._schema_name_];

            if (m)
                model = m;
            else if (s)
                model = new s(model);
            else if (!model)
                model = new Model(model);

            this.LOADED = true;

            for (let i = 0, l = this.sources.length; i < l; i++)
                this.sources[i].load(model);

            model.addView(this);

            for (let name in this.taps)
                this.taps[name].load(this._model_, false);

        }

        _down_(data, changed_values) {
            this._update_(data, changed_values, true);
        }

        _up_(tap, data, meta) {
            if (this.parent)
                this.parent._upImport_(tap._prop_, data, meta);
           //else
             //   tap._up_(data, null, true);

        }

        _upImport_(prop_name, data, meta) {
            if (this.taps[prop_name])
                this.taps[prop_name]._up_(data, meta);

        }

        _update_(data, changed_values, IMPORTED = false) {

            // if(!this.LOADED) return;

            if (this.update_tap)
                this.update_tap._downS_(data, IMPORTED);


            if (changed_values) {
                for (let name in changed_values)
                    if (this.taps[name])
                        this.taps[name]._downS_(data, IMPORTED);
            } else
                for (let name in this.taps)
                    this.taps[name]._downS_(data, IMPORTED);

            for (let i = 0, l = this.sources.length; i < l; i++)
                this.sources[i]._down_(data, changed_values);
        }
    }

    const uri_reg_ex = /(?:([^\:\?\[\]\@\/\#\b\s][^\:\?\[\]\@\/\#\b\s]*)(?:\:\/\/))?(?:([^\:\?\[\]\@\/\#\b\s][^\:\?\[\]\@\/\#\b\s]*)(?:\:([^\:\?\[\]\@\/\#\b\s]*)?)?\@)?(?:(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})|((?:[0-9a-f]{0,4})?(?:\:[0-9a-f]{0,4}){0,7})|([^\:\?\[\]\@\/\#\b\s]+(?:\.[^\:\?\[\]\@\/\#\b\s]*)*))?(?:\:(\d+))?((?:\/[^\?\[\]\#\/\s\b]*)+)?(?:\?([^\[\]\#\s\b]*))?(?:\#([^\#\s\b]*))?/;

    function fetchLocalText(URL, m = "same-origin") {
        return new Promise((res, rej) => {
            fetch(URL, {
                mode: m, // CORs not allowed
                credentials: m,
                method: "Get"
            }).then(r => {
                if (r.status !== 200)
                    rej("");
                else
                    r.text().then(str => res(str));
            }).catch(e => rej(e));
        });
    }

    function fetchLocalJSON(URL, m = "same-origin") {
        return new Promise((res, rej) => {
            fetch(URL, {
                mode: m, // CORs not allowed
                credentials: m,
                method: "Get"
            }).then(r => {
                if (r.status !== 200)
                    rej("");
                else
                    r.json().then(obj => res(obj));
            }).catch(e => rej(e));
        });
    }



    /**
     * Used for processing URLs, handling `document.location`, and fetching data.
     * @param      {string}   url           The URL string to wrap.
     * @param      {boolean}  USE_LOCATION  If `true` missing URL parts are filled in with data from `document.location`. 
     * @return     {WURL}   If a falsy value is passed to `url`, and `USE_LOCATION` is `true` a Global WURL is returned. This is directly linked to the page and will _update_ the actual page URL when its values are change. Use with caution. 
     * @alias WURL
     * @memberof module:wick.core.network
     */
    class WURL {

        constructor(url = "", USE_LOCATION = false) {
            
            let IS_STRING = true;

            let location = document.location;

            if (!url || typeof(url) != "string") {
                IS_STRING = false;
                if (WURL.GLOBAL && USE_LOCATION)
                    return WURL.GLOBAL;
            }

            /**
             * URL protocol
             */
            this.protocol = "";

            /**
             * Username string
             */
            this.user = "";

            /**
             * Password string
             */
            this.pwd = "";

            /**
             * URL hostname
             */
            this.host = "";

            /**
             * URL network port number.
             */
            this.port = 0;

            /**
             * URL resource path
             */
            this.path = "";

            /**
             * URL query string.
             */
            this.query = "";

            /**
             * Hashtag string
             */
            this.hash = "";

            /**
             * Map of the query data
             */
            this.map = null;

            if (IS_STRING) {
                if (url instanceof WURL) {
                    this.protocol = url.protocol;
                    this.user = url.user;
                    this.pwd = url.pwd;
                    this.host = url.host;
                    this.port = url.port;
                    this.path = url.path;
                    this.query = url.query;
                    this.hash = url.hash;
                } else {
                    let part = url.match(uri_reg_ex);
                    this.protocol = part[1] || ((USE_LOCATION) ? location.protocol : "");
                    this.user = part[2] || "";
                    this.pwd = part[3] || "";
                    this.host = part[4] || part[5] || part[6] || ((USE_LOCATION) ? location.hostname : "");
                    this.port = parseInt(part[7] || ((USE_LOCATION) ? location.port : 0));
                    this.path = part[8] || ((USE_LOCATION) ? location.pathname : "");
                    this.query = part[9] || ((USE_LOCATION) ? location.search.slice(1) : "");
                    this.hash = part[10] || ((USE_LOCATION) ? location.hash.slice(1) : "");
                }
            } else if (USE_LOCATION) {

                WURL.G = this;
                this.protocol = location.protocol;
                this.host = location.hostname;
                this.port = location.port;
                this.path = location.pathname;
                this.hash = location.hash.slice(1);
                this.query = location.search.slice(1);
                this._getQuery_(this.query);

                return WURL.R;
            }
            this._getQuery_(this.query);
        }


        /**
        URL Query Syntax

        root => [root_class] [& [class_list]]
             => [class_list]

        root_class = key_list

        class_list [class [& key_list] [& class_list]]

        class => name & key_list

        key_list => [key_val [& key_list]]

        key_val => name = val

        name => ALPHANUMERIC_ID

        val => NUMBER
            => ALPHANUMERIC_ID
        */

        /**
         * Pulls query string info into this.map
         * @private
         */
        _getQuery_() {
            let map = (this.map) ? this.map : (this.map = new Map());

            let lex = new Lexer(this.query);

            const get_map = (k, m) => (m.has(k)) ? m.get(k) : m.set(k, new Map).get(k);

            let key = 0,
                key_val = "",
                class_map = get_map(key_val, map),
                lfv = 0;

            while (!lex.END) {
                switch (lex.tx) {
                    case "&": //At new class or value
                        if (lfv > 0)
                            key = (class_map.set(key_val, lex.s(lfv)), lfv = 0, lex.n().pos);
                        else {
                            key_val = lex.s(key);
                            key = (class_map = get_map(key_val, map), lex.n().pos);
                        }
                        continue;
                    case "=":
                        //looking for a value now
                        key_val = lex.s(key);
                        lfv = lex.n().pos;
                        continue;
                }
                lex.n();
            }

            if (lfv > 0) class_map.set(key_val, lex.s(lfv));
        }

        setPath(path) {

            this.path = path;

            return new WURL(this);
        }

        setLocation() {
            history.replaceState({}, "replaced state", `${this}`);
            window.onpopstate();
        }

        toString() {
            let str = [];

            if(this.protocol && this.host)
                str.push(`${this.protocol}://`);

            if(this.host)
                str.push(`${this.host}`);

            if(this.port)
                str.push(`:${this.port}`);            
            
            if(this.path)
                str.push(`${this.path[0] == "/" ? "" : "/"}${this.path}`);      

            if(this.query)      
                str.push(this.query);

            return str.join("");
        }

        /**
         * Pulls data stored in query string into an object an returns that.
         * @param      {string}  class_name  The class name
         * @return     {object}  The data.
         */
        getData(class_name = "") {
            if (this.map) {
                let out = {};
                let _c = this.map.get(class_name);
                if (_c) {
                    for (let [key, val] of _c.entries())
                        out[key] = val;
                    return out;
                }
            }
            return null;
        }

        /**
         * Sets the data in the query string. Wick data is added after a second `?` character in the query field, and appended to the end of any existing data.
         * @param      {string}  class_name  Class name to use in query string. Defaults to root, no class 
         * @param      {object | Model | AnyModel}  data        The data
         */
        setData(data = null, class_name = "") {

            if (data) {



                let map = (this.map) ? this.map : (this.map = new Map());

                let store = (map.has(class_name)) ? map.get(class_name) : (map.set(class_name, new Map()).get(class_name));

                //If the data is a falsy value, delete the association.

                for (let n in data) {
                    if (data[n] && typeof data[n] !== "object")
                        store.set(n, data[n]);
                    else
                        store.delete(n);
                }

                //set query
                let null_class, str = "";

                if ((null_class = map.get(""))) {
                    if (null_class.size > 0) {
                        for (let [key, val] of null_class.entries())
                            str += `&${key}=${val}`;

                    }
                }

                for (let [key, class_] of map.entries()) {
                    if (key == "") continue;
                    if (class_.size > 0) {
                        str += `&${key}`;
                        for (let [key, val] of class_.entries())
                            str += `&${key}=${val}`;
                    }
                }

                str = str.slice(1);

                this.query = this.query.split("?")[0] + "?" + str;

                if (WURL.G == this)
                    this.goto();
            }

        }

        /**
         * Fetch a string value of the remote resource. 
         * Just uses path component of WURL. Must be from the same origin.
         * @param      {boolean}  [ALLOW_CACHE=true]  If `true`, the return string will be cached. If it is already cached, that will be returned instead. If `false`, a network fetch will always occur , and the result will not be cached.
         * @return     {Promise}  A promise object that resolves to a string of the fetched value.
         */
        fetchText(ALLOW_CACHE = true) {

            if (ALLOW_CACHE) {

                let resource = WURL.RC.get(this.path);

                if (resource)
                    return new Promise((res) => {
                        res(resource);
                    });
            }

            return fetchLocalText(this.path).then(res => (WURL.RC.set(this.path, res), res));
        }

        /**
         * Fetch a JSON value of the remote resource. 
         * Just uses path component of WURL. Must be from the same origin.
         * @param      {boolean}  [ALLOW_CACHE=true]  If `true`, the return string will be cached. If it is already cached, that will be returned instead. If `false`, a network fetch will always occur , and the result will not be cached.
         * @return     {Promise}  A promise object that resolves to a string of the fetched value.
         */
        fetchJSON(ALLOW_CACHE = true) {

            let string_url = this.toString();

            if (ALLOW_CACHE) {

                let resource = WURL.RC.get(string_url);

                if (resource)
                    return new Promise((res) => {
                        res(resource);
                    });
            }

            return fetchLocalJSON(string_url).then(res => (WURL.RC.set(this.path, res), res));
        }

        /**
         * Cache a local resource at the value 
         * @param    {object}  resource  The resource to store at this URL path value.
         * @returns {boolean} `true` if a resource was already cached for this URL, false otherwise.
         */
        cacheResource(resource) {

            let occupied = WURL.RC.has(this.path);

            WURL.RC.set(this.path, resource);

            return occupied;
        }
        /**
         * Goes to the current URL.
         */
        goto() {
            return;
            let url = this.toString();
            history.pushState({}, "ignored title", url);
            window.onpopstate();
            WURL.G = this;
        }
    }

    /**
     * The fetched resource cache.
     */
    WURL.RC = new Map();

    /**
     * The Default Global WURL object. 
     */
    WURL.G = null;

    /**
     * The Global object Proxy.
     */
    WURL.R = {
        get protocol() { return WURL.G.protocol; },
        set protocol(v) {
            return;
            WURL.G.protocol = v;
        },
        get user() { return WURL.G.user; },
        set user(v) {
            return;
            WURL.G.user = v;
        },
        get pwd() { return WURL.G.pwd; },
        set pwd(v) {
            return;
            WURL.G.pwd = v;
        },
        get host() { return WURL.G.host; },
        set host(v) {
            return;
            WURL.G.host = v;
        },
        get port() { return WURL.G.port; },
        set port(v) {
            return;
            WURL.G.port = v;
        },
        get path() { return WURL.G.path; },
        set path(v) {
            return;
            WURL.G.path = v;
        },
        get query() { return WURL.G.query; },
        set query(v) {
            return;
            WURL.G.query = v;
        },
        get hash() { return WURL.G.hash; },
        set hash(v) {
            return;
            WURL.G.hash = v;
        },
        get map() { return WURL.G.map; },
        set map(v) {
            return;
            WURL.G.map = v;
        },
        setPath(path) { return WURL.G.setPath(path); },
        setLocation() { return WURL.G.setLocation(); },
        toString() { return WURL.G.toString(); },
        getData(class_name = "") { return WURL.G.getData(class_name = ""); },
        setData(class_name = "", data = null) { return WURL.G.setData(class_name, data); },
        fetchText(ALLOW_CACHE = true) { return WURL.G.fetchText(ALLOW_CACHE); },
        cacheResource(resource) { return WURL.G.cacheResource(resource); }
    };
    Object.freeze(WURL.R);
    Object.freeze(WURL.RC);
    Object.seal(WURL);

    /**
     * To be extended by objects needing linked list methods.
     * @alias module:wick~internals.LinkedList
     */
    const LinkedList = {

        props: {
            /**
             * Properties for horizontal graph traversal
             * @property {object}
             */
            defaults: {
                /**
                 * Next sibling node
                 * @property {object | null}
                 */
                nxt: null,

                /**
                 * Previous sibling node
                 * @property {object | null}
                 */
                prv: null
            },

            /**
             * Properties for vertical graph traversal
             * @property {object}
             */
            children: {
                /**
                 * Number of children nodes.
                 * @property {number}
                 */
                noc: 0,
                /**
                 * First child node
                 * @property {object | null}
                 */
                fch: null,
            },
            parent: {
                /**
                 * Parent node
                 * @property {object | null}
                 */
                par: null
            }
        },

        methods: {
            /**
             * Default methods for Horizontal traversal
             */
            defaults: {

                next: function() {
                    return this.nxt;
                },

                prev: function() {
                    return this.prv;
                },

                insertBefore: function(node) {

                    if (!this.nxt || !this.prv) {
                        this.nxt = this;
                        this.prv = this;
                    }

                    if (node.prv || node.nxt) {
                        node.prv.nxt = node.nxt;
                        node.nxt.prv = node.prv;
                    }

                    node.prv = this.prv;
                    this.prv.nxt = node;
                    node.nxt = this;
                    this.prv = node;
                },

                insertAfter: function(node) {

                    if (!this.nxt || !this.prv) {
                        this.nxt = this;
                        this.prv = this;
                    }

                    if (node.prv || node.nxt) {
                        node.prv.nxt = node.nxt;
                        node.nxt.prv = node.prv;
                    }

                    this.nxt.prv = node;
                    node.nxt = this.nxt;
                    this.nxt = node;
                    node.prv = this;
                }
            },
            /**
             * Methods for both horizontal and vertical traversal.
             */
            parent_child: {
                /**
                 *  Returns eve. 
                 * @return     {<type>}  { description_of_the_return_value }
                 */
                root(){
                    return this.eve();
                },
                /**
                 * Returns the root node. 
                 * @return     {Object}  return the very first node in the linked list graph.
                 */
                eve(){
                    if(this.par)
                        return this.par.eve();
                    return this;
                },

                push(node) {
                    this.addC(node);
                },

                unshift(node) {
                    this.addC(node, (this.fch) ? this.fch.pre : null);
                },

                insertBefore: function(node) {
                    if (node.par)
                        node.par.remove(node);
                    if (this.par)
                        this.par.add(node, this.pre);
                    else
                        LinkedList.methods.defaults.insertBefore.call(this, node);
                },

                insertAfter: function(node) {
                    if (node.par)
                        node.par.remove(node);
                    if (this.par)
                        this.par.add(node, this);
                    else 
                    	LinkedList.methods.defaults.insertAfter.call(this, node);
                },

                addC: function(child = null, prev = null) {

                    if (!child) return;

                    if (child.par)
                        child.par.remC(child);

                    if (prev && prev.par && prev.par == this) {
                        if (child == prev) return;
                        child.prv = prev.prv;
                        prev.prv.nxt = child;
                        child.nxt = prev;
                        prev.prv = child;
                    } else if (this.fch) {
                        child.prv = this.fch.prv;
                        this.fch.prv.nxt = child;
                        child.nxt = this.fch;
                        this.fch.prv = child;
                    } else {
                        this.fch = child;
                        child.nxt = child;
                        child.prv = child;
                    }

                    child.par = this;
                    this.noc++;
                },

                /**
                 * Analogue to HTMLElement.removeChild()
                 *
                 * @param      {HTMLNode}  child   The child
                 */
                remC: function(child) {
                    if (child.par && child.par == this) {
                        child.prv.nxt = child.nxt;
                        child.nxt.prv = child.prv;

                        if (child.prv == child || child.nxt == child) {
                            if (this.fch !== child)
                                debugger
                            this.fch = null;
                        } else if (this.fch == child)
                            this.fch = child.nxt;

                        child.prv = null;
                        child.nxt = null;
                        child.par = null;
                        this.noc--;
                    }
                },

                /**
                 * Gets the next node. 
                 *
                 * @param      {HTMLNode}  node    The node to get the sibling of.
                 * @return {HTMLNode | TextNode | undefined}
                 */
                getN: function(node = this.fch) {
                    if (node && node.nxt != this.fch)
                        return node.nxt;
                    return null;
                },

                /**
                 * Gets the child at index.
                 *
                 * @param      {number}  index   The index
                 */
                getCAtI: function(index, node = this.fch) {
                    let first = node;
                    let i = 0;
                    while (node && node != first) {
                        if (i++ == index)
                            return node;
                        node = node.nxt;
                    }
                },
            }
        },

        setGettersAndSetters: (obj) => {
            Object.defineProperties(obj, LL_GS_LIST);
        }
    };

    const LL_GS_LIST = {
        children: {
            enumerable: true,
            configurable: true,
            /**
             * @return {array} Returns an array of all children.
             */
            get: function() {
                for (var z = [], i = 0, node = this.fch; i++ < this.noc;)(
                    z.push(node), node = node.nxt
                );
                return z;
            },

            set: function(e) {
                /* No OP */
            }
        }
    };

    /** NODE TYPE IDENTIFIERS **/
    const HTML = 0;
    const TEXT = 1;


    /**
     * An AST node for text data.
     * @param  {string}  str     The text value of the node.
     * @memberof module:wick~internals.html
     * @alias TextNode
     */
    class TextNode {

        constructor(str = "") {
            /**
             * The text value
             */
            this.txt = str;
        }

        /**
         * Returns the type of `1` (`TEXT`)
         */
        get type() {
            return TEXT;
        }

        /**
         * Returns a string representation of the object.
         * @param      {string}  str     Optional string passed down from calling method.
         * @return     {string}  String representation of the object.
         */
        toString() {
            return `${this.txt}`;
        }

        /**
         * Builds a real DOM HTMLTextNode node. 
         * @param      {HTMLElement}  parent  The real html element.
         */
        _build_(parent) {
            parent.appendChild(document.createTextNode(this.txt));
        }

    }



    /**
     * TextNode implements some of LinkedList
     * @extends LinkedList
     * @memberof  module:wick~internals.html.TextNode
     */
    Object.assign(TextNode.prototype, LinkedList.props.defaults, LinkedList.props.parent, LinkedList.methods.defaults);



    /**
     * An AST node for HTML data. 
     * Handles the parsing of HTML strings.
     * @memberof module:wick~internals.html
     * @alias HTMLNode
     */
    class HTMLNode {

        constructor() {

            /**
             * Element _attributes_
             * @public
             */
            this._attributes_ = [];

            /**
             * Any Comment Lines found within.
             * @private
             */
            //this.dtd_nodes = [];

            /**
             * The tag name of the object.
             * @public
             */
            this.tag = "";

            /**
             * A WURL instance when set.
             * @private
             */
            this.url = null;

            /**
             * Whether the node is a DTD, such as a comment.
             * @private
             */
            this.DTD = false;

        }



        /******************************************* ATTRIBUTE AND ELEMENT ACCESS ******************************************************************************************************************/



        /**
         * Returns the type of `0` (`HTML`)
         * @public
         */
        get type() {
            return HTML;
        }

        get tagName() {
            return this.tag.toUpperCase();
        }

        get classList() {
            let classes = this.getAttrib("class");
            if (typeof classes.value == "string")
                return classes.split(" ");
            return [];
        }

        getAttribute(name) {
            let attrib = this.getAttrib(name);
            return (attrib) ? attrib.value : void 0;
        }

        getAttribute(name) {
            let attrib = this.getAttrib(name);
            return (attrib) ? attrib.value : void 0;
        }


        get parentElement() {
            return this.par;
        }

        get previousElementSibling() {
            if (this.par) {
                let guard = this.par.fch;

                if (this == guard) return null;

                let node = this.pre;

                while (node && node != gaurd) {
                    if (node.type == HTML)
                        return node;
                    node = node.pre;
                }

                if (node.type == HTML)
                    return node;
            }
            return null;
        }

        get nextElementSibling() {
            if (this.par) {
                let guard = this.par.fch;

                let node = this.nxt;

                while (node && node != guard) {
                    if (node.type == HTML)
                        return node;
                    node = node.nxt;
                }
            }
            return null;
        }



        /**
         * Gets an attribute.
         * @param      {string}  prop    The attribute name to lookup;
         * @public
         */
        getAttrib(prop) {
            for (let i = -1, l = this._attributes_.length; ++i < l;) {
                let attrib = this._attributes_[i];
                if (attrib.name == prop) return attrib;
            }
            return null;
        }



        /**
         * Get Elements by the tag name.
         * @param      {string}   tag                  A string to match with the element's tag value.
         * @param      {boolean}  [INCLUDE_DESCENDANTS=false]  When `true` searching will recurse depth first into child elements.
         * @param      {Array}    array                Internal element store that is returned. 
         * @return     {Array}    An array of matched elements.
         * @public
         */
        getTag(tag, INCLUDE_DESCENDANTS = false, array = []) {
            for (let node = this.fch; node;
                (node = this.getN(node))) {
                if (node.type == HTML) {
                    if (node.tag == tag) array.push(node);
                    if (INCLUDE_DESCENDANTS) node.getTag(tag, INCLUDE_DESCENDANTS, array);
                }
            }
            return array;
        }



        /**
         * Get Elements by the tag name.
         * @param      {string}   _class               A string to find with the element's class value.
         * @param      {boolean}  [INCLUDE_DESCENDANTS=false]  When `true` searching will recurse depth first into child elements.
         * @param      {Array}    array                Internal element store that is returned. 
         * @return     {Array}    An array of matched elements.
         * @public
         */
        getClass(_class, INCLUDE_DESCENDANTS = false, array = []) {
            for (let node = this.fch; node;
                (node = this.getN(node))) {
                if (node.type == HTML) {
                    if (node.class.includes(_class)) array.push(node);
                    if (INCLUDE_DESCENDANTS) node.getClass(_class, INCLUDE_DESCENDANTS, array);
                }
            }
            return array;
        }



        /**
         * Get first element with matching id.
         * @param      {string}   id                   The identifier value to find.
         * @param      {boolean}  [INCLUDE_DESCENDANTS=false]  When `true` searching will recurse depth first into child elements.
         * @return     {HTMLNode}   The first element whose id matches.
         * @public
         */
        getID(id, INCLUDE_DESCENDANTS = false) {
            for (let node = this.fch, ch; node;
                (node = this.getN(node))) {
                if (node.type == HTML) {
                    if (node.id == id) return node;
                    if (INCLUDE_DESCENDANTS && (ch = node.getID(id, INCLUDE_DESCENDANTS))) return ch;
                }
            }
            return null;
        }



        /**
         * The id attribute value.
         * @public
         */
        get id() {
            let id_attrib = this.getAttrib("id");
            return (id_attrib) ? id_attrib.value : "";
        }



        /**
         * The class attribute value.
         * @public
         */
        get class() {
            let id_attrib = this.getAttrib("class");
            return (id_attrib) ? id_attrib.value : "";
        }



        /**
         * Returns a string representation of the object.
         * @return     {string}  String representation of the object.
         * @public
         */
        toString() {
            let str = `<${this.tag}`,
                atr = this._attributes_,
                i = -1,
                l = atr.length;

            while (++i < l) {
                let attr = atr[i];
                str += ` ${attr.name}="${attr.value}"`;
            }

            str += ">";

            for (let node = this.fch; node;
                (node = this.getN(node))) {
                str += node.toString();
            }


            return str + `</${this.tag}>`;
        }



        /******************************************* PARSING ******************************************************************************************************************/



        /**
         * Creates a text node. 
         *
         * @param      {Lexer} - A Lexical tokenizing object supporting methods found in {@link Lexer}
         * @param      {start}  start   The starting point of the data slice
         * @private
         */
        _createTextNode_(lex, start, end) {
            if (end) {
                let other_lex = lex.copy();
                other_lex.IWS = true;
                other_lex.off = start - 1;
                other_lex.tl = 1;
                other_lex.sl = end;
                other_lex.n();
                let text_node = this._processTextNodeHook_(other_lex, true);
                if (text_node) this.addC(text_node);
            } else if (start < lex.off) {
                let other_lex = lex.copy();
                other_lex.off = start;
                other_lex.tl = 0;
                other_lex.fence(lex);
                other_lex.IWS = false;
                other_lex.n();
                other_lex.IWS = true;

                if ((other_lex.sl - other_lex.off) < 2)
                    debugger;

                let text_node = this._processTextNodeHook_(other_lex, false);
                if (text_node) this.addC(text_node);
            }
        }



        /**
         * Parses an HTML open tag.
         * @param {Lexer} - A Lexical tokenizing object supporting methods found in {@link Lexer}  
         * @param {Object} attribs - An object which will receive the attribute keys and values. 
         * @private
         */
        _parseOpenTag_(lex, DTD) {
            let HAS_URL = false;

            while (!lex.END && lex.text !== ">" && lex.text !== "/") {

                if (DTD && lex.ch == "-" && lex.pk.ch == "-") {
                    //_parse_ comment

                    let pk = lex.pk;
                    if (!lex.text) throw Error("Unexpected end of input.");
                    let a = pk.n().ch,
                        b = pk.n().ch;
                    while (!pk.END && (b !== "-" || a !== "-")) {
                        a = b;
                        b = pk.n().tx;
                    }
                    lex.sync().n();
                    continue;
                }

                lex.IWS = false;
                
                let pk = lex.pk;
                
                while (!pk.END && !(pk.ty & (pk.types.ws | pk.types.str | pk.types.nl)) && pk.ch !== "=" && pk.ch !== ">") { pk.n(); }
                
                let attrib_name = pk.slice(lex);
                
                lex.sync(); 
                
                lex.IWS = true;

                let out_lex = lex.copy();
                
                out_lex.sl = lex.off;

                if (lex.ch == "=") {
                    let pk = lex.pk;

                    let start = pk.off;

                    pk.IWS = true;
                    while (!(pk.ty & (pk.types.ws | pk.types.str | pk.types.nl)) && pk.ch !== ">") { pk.n(); }
                    pk.IWS = false;

                    if (pk.off > start) {
                        out_lex = lex.n().copy();
                        out_lex.fence(pk);
                        lex.sync();
                    } else {
                        //Have simple value
                        lex.sync(pk);
                        out_lex = lex.copy();
                        if (lex.pos < 0)
                            lex.throw(`Unexpected end of input. Expecting value for attribute "${attrib_name}"`);
                        else if (lex.type == lex.types.str) {
                            out_lex.tl = 1;
                            out_lex.n();
                            out_lex.sl = lex.pos + lex.tl - 1;
                            lex.n();
                        } else {
                            lex.next();
                            out_lex.fence(lex);
                        }
                    }
                }

                if (attrib_name == "url") {
                    this.url = new WURL(out_lex.slice());
                    HAS_URL = true;
                }

                let attrib = this._processAttributeHook_(attrib_name, out_lex);

                if (attrib)
                    this._attributes_.push(attrib);
            }

            if (lex.text == "/") // Void Nodes
                lex.assert("/");

            return HAS_URL;
        }

        _parseRunner_(lex = null, OPENED = false, IGNORE_TEXT_TILL_CLOSE_TAG = false, parent = null) {
            let start = lex.pos;
            let end = lex.pos;
            let HAS_INNER_TEXT = false;

            while (!lex.END) {

                switch (lex.ch) {
                    case "/":
                        if (lex.pk.ch == "<") { //ignore the white space.
                            lex.sync();
                            break;
                        }
                        break;

                    case "<":
                        if (!IGNORE_TEXT_TILL_CLOSE_TAG) lex.IWS = true;

                        let pk = lex.pk;

                        if (pk.ch == "/") {
                            if (IGNORE_TEXT_TILL_CLOSE_TAG && pk.pk.tx !== this.tag) break;

                            if (HAS_INNER_TEXT) {
                                if (IGNORE_TEXT_TILL_CLOSE_TAG)
                                    this._createTextNode_(lex, start);
                                else if ((end - start) > 0)
                                    this._createTextNode_(lex, start, end);
                            }

                            //Close tag
                            let name = lex.sync().n().tx;

                            //Close tag is not the one we are looking for. We'll create a new dummy node and close the tag with it. 
                            if (name !== this.tag) {
                                //Create new node with the open tag 
                                let insert = new HTMLNode();
                                insert.tag = name;
                                this.addC(insert);
                            }

                            lex.n();
                            lex.IWS = false;
                            lex.a(">");

                            this._endOfElementHook_();

                            return this;
                        }

                        if (pk.ch == "!") {
                            /* DTD - Doctype and Comment tags*/
                            //This type of tag is dropped
                            while (!lex.END && lex.n().ch !== ">") {}                        lex.a(">");
                            continue;
                        }

                        if (!IGNORE_TEXT_TILL_CLOSE_TAG) {
                            //Open tag
                            if (!OPENED) {
                                let URL = false;
                                this.DTD = false;
                                this._attributes_.length = 0;

                                //Expect tag name 
                                this.tag = lex.n().tx.toLowerCase();


                                URL = this._parseOpenTag_(lex.n());
                                start = lex.pos + 1;
                                lex.IWS = false;
                                if (lex.ch == "/") lex.n();
                                lex.a(">");


                                OPENED = true;

                                HAS_INNER_TEXT = IGNORE_TEXT_TILL_CLOSE_TAG = this._ignoreTillHook_(this.tag);

                                if (URL) {

                                    //Need to block against ill advised URL fetches. 

                                    //Hook to pull in data from remote resource
                                    let prom = this._processFetchHook_(lex, true, IGNORE_TEXT_TILL_CLOSE_TAG, parent);

                                    if (prom instanceof Promise) {
                                        return prom.then(() => {
                                            if (this._selfClosingTagHook_(this.tag)) {
                                                return this;
                                            } // Tags without matching end tags.
                                            return this._parseRunner_(lex, true, IGNORE_TEXT_TILL_CLOSE_TAG, this);
                                        });
                                    }
                                }

                                if (this._selfClosingTagHook_(this.tag)) // Tags without matching end tags.
                                    return this;

                                continue;
                            } else {
                                lex.IWS = false;
                                //Create text node;
                                if (HAS_INNER_TEXT) {
                                    if (IGNORE_TEXT_TILL_CLOSE_TAG)
                                        this._createTextNode_(lex, start);
                                    else if ((end - start) > 0) {
                                        this._createTextNode_(lex, start, end);
                                    }
                                }

                                //New Child node found
                                let node = this._createHTMLNodeHook_(lex.pk.tx, lex.off);

                                this.addC(node);

                                return node._parse_(lex, false, false, this).then(child => {
                                    if (child.DTD) node.remC(child);
                                    return this._parseRunner_(lex, OPENED, false, this);
                                });
                            }
                            //}
                        }
                        lex.IWS = false;
                        break;
                }

                if (!IGNORE_TEXT_TILL_CLOSE_TAG) {
                    if (lex.ty == 8 && !HAS_INNER_TEXT) {
                        start = lex.pos;
                    } else if (lex.ty == 256) ; else {
                        HAS_INNER_TEXT = true;
                        end = lex.off + lex.tl;
                    }
                }

                lex.n();
            }

            if (OPENED && start < lex.off) {
                //console.log("OPEND TEXT IMPORT", lex.slice(start));
                //Got here from an network import, need produce a text node;
                this._createTextNode_(lex, start);
            }

            return this;
        }

        /**
         * Parses HTML string. Appends new nodes, or consumes first node if tag is an empty string.
         * @param      {Lexer} - A Lexical tokenizing object supporting methods found in {@link Lexer}
         * @param      {boolean}  OPENED       The opened
         * @param      {boolean}  IGNORE_TEXT_TILL_CLOSE_TAG  If `true`, parser will ignore all HTML syntax until the closing tag is found.
         * @return     {Promise}  
         * @private
         */
        _parse_(lex = null, OPENED = false, IGNORE_TEXT_TILL_CLOSE_TAG = false, parent = null) {
            lex.IWS = false;
            return new Promise((res, rej) => {
                res(this._parseRunner_(lex, OPENED, IGNORE_TEXT_TILL_CLOSE_TAG, parent, res, rej));
            });
        }



        /******************************************* HOOKS ******************************************************************************************************************/



        /**
         * Override this to act on the finished node, right before the parse function completes and returns.
         */
        _endOfElementHook_() {}



        /**
         * Override this method to tell the parser that `tag` is self closing and to not look for a matching close tag by returning `true`.
         * @param      {string}  tag     The HTML tag
         */
        _selfClosingTagHook_(tag) {
            switch (tag) {
                case "input":
                case "br":
                case "img":
                    return true;
            }

            return false;
        }



        /**
         * Override this method to tell the parser to not to parse innerHTML by returning `true`
         * @param      {string}   tag     The HTML tag
         * @return     {boolean}  If `true` is returned, parser will not react to any more HTML markup until the closing tag for this node is found.
         * @public
         */
        _ignoreTillHook_(tag) {
            if (tag == "script" || tag == "style") // Special character escaping tags.
                return true;
            return false;
        }



        /**
         * Override this method to create a different node type for the given `tag` string.
         * > If overridden, returned node should support:
         * > - All properties and methods in {@link LinkedList}
         * > - All properties and methods in {@link HTMLNode}
         * @param      {string}    tag     The name of the tag to create. 
         * @param      {number} start Marks the offset position of the `<` character of the open tag. Can be used to walk the Lexer back and parse the open tag characters again.
         * @return     {HTMLNode}  returns a new HTMLNode.
         * @public
         */
        _createHTMLNodeHook_(tag, start) { return new HTMLNode(tag); }



        /**
         * Override this method to process how a url based resource is fetched.
         * > If overridden:  
         * > - Should return null or a Promise that resumes html parsing by calling this._parse_(`lexer`, `OPENED`, `IGNORE_TEXT_TILL_CLOSE_TAG`, `parent`).
         * > - Please make sure a call to `this._parse_` includes `lexer`, `OPENED`, `IGNORE_TEXT_TILL_CLOSE_TAG`, and `parent`.
         * @param      {Lexer} - A Lexical tokenizing object supporting methods found in {@link Lexer}. It contains the HTML string being _parse_d.
         * @param      {boolean}  OPENED       Always set to `true`.
         * @param      {boolean}  IGNORE_TEXT_TILL_CLOSE_TAG  If `true`, parser will ignore all HTML syntax until the closing tag is found. 
         * @param      {HTMLNode|object}  parent       The parent node.
         * @return     {boolean | Promise}  If additional processing must be done asynchronously, return a `Promise` which will call this._parse_ when it is resolved.
         * @public
         */
        _processFetchHook_(lexer, OPENED, IGNORE_TEXT_TILL_CLOSE_TAG, parent, url) {
            let path = this.url.path,
                CAN_FETCH = true;

            //make sure URL is not already called by a parent.
            while (parent) {
                if (parent.url && parent.url.path == path) {
                    console.warn(`Preventing recursion on resource ${this.url.path}`);
                    CAN_FETCH = false;
                    break;
                }
                parent = parent.par;
            }

            if (CAN_FETCH) {
                return this.url.fetchText().then((text) => {
                    let lexer = new Lexer(text);
                    return this._parseRunner_(lexer, true, IGNORE_TEXT_TILL_CLOSE_TAG, this);
                }).catch((e) => {
                    console.log(e);
                });
            }
            return null;
        }



        /**
         * Override this method to _parse_ attribute data. 
         * @param      {string}  name   The attribute name
         * @param      {string}  value  The attribute value
         * @return     {Object}  An attribute object to store in the `this._attributes_` array.
         * @public
         */
        _processAttributeHook_(name, lex) { return { name, value: lex.slice() }; }



        /**
         * Override this to process new TextNode data as it is encountered.
         * @param      {string}  text_node  The text node
         * @return     {TextNode}  TextNode to add to children list. Return null instead to prevent the node from being entered.
         * @public
         */
        _processTextNodeHook_(lex, IS_INNER_HTML) {
            if (!IS_INNER_HTML)
                return new TextNode(lex.slice());
            let txt = "";

            lex.IWS = true;

            while (!lex.END) {
                if (lex.ty == 8) {
                    txt += " ";
                } else if (lex.ty == 256) ; else {
                    txt += lex.tx;
                }
                lex.IWS = false;
                lex.n();
            }

            if (txt.length > 0) {
                return new TextNode(txt.trim());
            }

            return null;
        }



        /**
         * Constructs a new HTMLElement and appends to the parent element.
         * Iterates through children nodes, calling their `_build_` method, passing in it's own HTMLElement as the argument for parent. 
         * @param {HTMLElement}  parent  The parent HTMLElement to append sub elements to.
         */
        _build_(parent) {
            let ele = document.createElement(this.tag);

            for (let i = 0, l = this._attributes_.length; i < l; i++) {
                let attr = this._attributes_[i];
                ele.setAttribute(attr.name, attr.value);
            }
            //let passing_element = ele;
            let passing_element = (this.tag == "template") ? ele.content : ele;

            for (let node = this.fch; node;
                (node = this.getN(node))) {
                node._build_(passing_element);
            }

            if (parent) parent.appendChild(ele);

            return ele;
        }
    }



    /**
     * HTMLNode implements all of LinkedList
     * @extends LinkedList
     * @memberof  module:wick~internals.html.HTMLNode
     * @private
     */
    Object.assign(HTMLNode.prototype, LinkedList.props.defaults, LinkedList.props.children, LinkedList.props.parent, LinkedList.methods.defaults, LinkedList.methods.parent_child);
    LinkedList.setGettersAndSetters(HTMLNode.prototype);




    /**
     * Builds an HTML AST. 
     * @function
     * @param {string} html_string - A string containing HTML data.
     * @param {string} css_string - An existing CSSRootNode to merge with new `selectors` and `rules`.
     * @return {Promise} Returns a `Promise` that will return a new or existing CSSRootNode.
     * @memberof module:wick.core
     * @alias html
     */
    const HTMLParser = (html_string, root = null) => (root = (!root || !(root instanceof HTMLNode)) ? new HTMLNode() : root, root._parse_(new Lexer(html_string.replace(/\&lt;/g, "<").replace(/\&gt;/g, ">"), true)));

    /**
     * Used to _bind_ a rule to a CSS selector.
     * @param      {string}  selector        The raw selector string value
     * @param      {array}  selector_array  An array of selector group identifiers.
     * @memberof module:wick~internals.css
     * @alias CSSSelector
     */
    class CSSSelector {

        constructor(selector /* string */ , selector_array /* array */ ) {

            /**
             * The raw selector string value
             * @package
             */
            this.v = "";

            this.v = selector;

            /**
             * Array of separated selector strings in reverse order.
             * @package
             */
            this.a = [];

            this.a = selector_array;

            /**
             * The CSSRule to _bind_ to.
             * @package
             */
            this.r = null;
        }

        /**
         * Returns a string representation of the object.
         * @return     {string}  String representation of the object.
         */
        toString() {
            let str = `${this.v} {`;

            if (this.r) {
                let rule = this.r;
                for (let n in this.r) {
                    str += this.r.toString() + ";";
                }
            }
            return str + "}";
        }

    }

    /**
     * Holds a set of rendered CSS properties.
     * @memberof module:wick~internals.css
     * @alias CSSRule
     */
    class CSSRule {
        constructor() {
            /**
             * Collection of properties held by this rule.
             * @public
             */
            this.props = {};
            this.LOADED = false;
        }

        addProperty(prop) {
            if (prop)
                this.props[prop.name] = prop.value;
        }

        toString() {
            let str = [];

            for (let a in this.props) {
                if(Array.isArray(this.props[a]))
                    str.push(a.replace(/\_/g, "-"), ":", this.props[a].join(" "), ";");
                else
                    str.push(a.replace(/\_/g, "-"), ":", this.props[a].toString(), ";");
            }
            
            return str.join("") //JSON.stringify(this.props).replace(/\"/g, "").replace(/\_/g, "-");
        }

        merge(rule) {
            if (rule.props) {
                for (let n in rule.props)
                    this.props[n] = rule.props[n];
                this.LOADED = true;
            }
        }

        get _wick_type_() { return 0; }

        set _wick_type_(v) {}
    }

    /**
     * wick internals.
     * @class      NR (name)
     */
    class NR { //Notation Rule

        constructor() {

            this.r = [NaN, NaN];
            this._terms_ = [];
            this._prop_ = null;
            this._virtual_ = false;
        }

        sp(value, rule) { //Set Property
            if (this._prop_){
                if (value)
                    if (Array.isArray(value) && value.length === 1 && Array.isArray(value[0]))
                        rule[this._prop_] = value[0];
                    else
                        rule[this._prop_] = value;
            }
        }

        isRepeating() {
            return !(isNaN(this.r[0]) && isNaN(this.r[1]));
        }

        _parse_(lx, rule, out_val) {
            if (typeof(lx) == "string")
                lx = new Lexer(lx);

            let r = out_val || { v: null },
                start = isNaN(this.r[0]) ? 1 : this.r[0],
                end = isNaN(this.r[1]) ? 1 : this.r[1];

            return this.___(lx, rule, out_val, r, start, end);
        }

        ___(lx, rule, out_val, r, start, end) {
            let bool = true;
            for (let j = 0; j < end && !lx.END; j++) {

                for (let i = 0, l = this._terms_.length; i < l; i++) {
                    bool = this._terms_[i]._parse_(lx, rule, r);
                    if (!bool) break;
                }

                if (!bool) {

                    this.sp(r.v, rule);

                    if (j < start)
                        return false;
                    else
                        return true;
                }
            }

            this.sp(r.v, rule);

            return true;
        }
    }

    class AND extends NR {
        ___(lx, rule, out_val, r, start, end) {

            outer:
                for (let j = 0; j < end && !lx.END; j++) {
                    for (let i = 0, l = this._terms_.length; i < l; i++)
                        if (!this._terms_[i]._parse_(lx, rule, r)) return false;
                }

            this.sp(r.v, rule);

            return true;
        }
    }

    class OR extends NR {
        ___(lx, rule, out_val, r, start, end) {
            let bool = false;

            for (let j = 0; j < end && !lx.END; j++) {
                bool = false;

                for (let i = 0, l = this._terms_.length; i < l; i++)
                    if (this._terms_[i]._parse_(lx, rule, r)) bool = true;

                if (!bool && j < start) {
                    this.sp(r.v, rule);
                    return false;
                }
            }

            this.sp(r.v, rule);

            return true;
        }
    }

    class ONE_OF extends NR {
        ___(lx, rule, out_val, r, start, end) {
            let bool = false;

            for (let j = 0; j < end && !lx.END; j++) {
                bool = false;

                for (let i = 0, l = this._terms_.length; i < l; i++) {
                    bool = this._terms_[i]._parse_(lx, rule, r);
                    if (bool) break;
                }

                if (!bool)
                    if (j < start) {
                        this.sp(r.v, rule);
                        return false;
                    }
            }

            this.sp(r.v, rule);

            return bool;
        }
    }

    class Color extends Float64Array {

        constructor(r, g, b, a = 0) {
            super(4);

            this.r = 0;
            this.g = 0;
            this.b = 0;
            this.a = 1;

            if (r) {
                this.r = r; //Math.max(Math.min(Math.round(r),255),-255);
                this.g = g; //Math.max(Math.min(Math.round(g),255),-255);
                this.b = b; //Math.max(Math.min(Math.round(b),255),-255);
                this.a = a; //Math.max(Math.min(a,1),-1);
            }
        }

        get r() {
            return this[0];
        }

        set r(r) {
            this[0] = r;
        }

        get g() {
            return this[1];
        }

        set g(g) {
            this[1] = g;
        }

        get b() {
            return this[2];
        }

        set b(b) {
            this[2] = b;
        }

        get a() {
            return this[3];
        }

        set a(a) {
            this[3] = a;
        }

        set(color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            this.a = (color.a != undefined) ? color.a : this.a;
        }

        add(color) {
            return new Color(
                color.r + this.r,
                color.g + this.g,
                color.b + this.b,
                color.a + this.a
            )
        }

        mult(color) {
            if (typeof(color) == "number") {
                return new Color(
                    this.r * color,
                    this.g * color,
                    this.b * color,
                    this.a * color
                )
            } else {
                return new Color(
                    this.r * color.r,
                    this.g * color.g,
                    this.b * color.b,
                    this.a * color.a
                )
            }
        }

        sub(color) {
            return new Color(
                this.r - color.r,
                this.g - color.g,
                this.b - color.b,
                this.a - color.a
            )
        }

        toString() {
            return `rgba(${this.r|0},${this.g|0},${this.b|0},${this.a})`;
        }

        toJSON() {
            return `rgba(${this.r|0},${this.g|0},${this.b|0},${this.a})`;
        }
    }

    /*
        BODY {color: black; background: white }
        H1 { color: maroon }
        H2 { color: olive }
        EM { color: #f00 }              // #rgb //
        EM { color: #ff0000 }           // #rrggbb //
        EM { color: rgb(255,0,0) }      // integer range 0 - 255 //
        EM { color: rgb(100%, 0%, 0%) } // float range 0.0% - 100.0% //
    */



    class CSS_Color extends Color {

        static _parse_(l, rule, r) {

            let c = CSS_Color._fs_(l);

            if (c) {
                l.n();

                return c;
            }
            return null;
        }
        /**
            Creates a new Color from a string or a Lexer.
        */
        static _fs_(l, c) {

            if (!(l instanceof Lexer))
                l = new Lexer(l);

            let out = { r: 0, g: 0, b: 0, a: 1 };

            switch (l.ch) {
                case "#":
                    var value = l.n().tx;
                    break;
                case "r":
                    let tx = l.tx;
                    if (tx == "rgba") {
                        l.n(); // (
                        out.r = parseInt(l.n().tx);
                        l.n(); // ,
                        out.g = parseInt(l.n().tx);
                        l.n(); // ,
                        out.b = parseInt(l.n().tx);
                        l.n(); // ,
                        out.a = parseFloat(l.n().tx);
                        l.n().n();
                        break;
                    } else if (tx == "rgb") {
                        l.n(); // (
                        out.r = parseInt(l.n().tx);
                        l.n(); // ,
                        out.g = parseInt(l.n().tx);
                        l.n(); // ,
                        out.b = parseInt(l.n().tx);
                        l.n();
                        break;
                    }
                default:
                    let string = l.tx;

                    if (l.ty == l.types.str)
                        string = string.slice(1, -1);

                    out = CSS_Color.colors[string.toLowerCase()];

                    if (!out) return null;
            }

            if (!c)
                c = new CSS_Color();

            c.set(out);

            return c;
        }
    } {
        let _$ = (r = 0, g = 0, b = 0, a = 1) => ({ r, g, b, a });
        let c = _$(0, 255, 25);
        CSS_Color.colors = {
            "alice blue": _$(240, 248, 255),
            "antique white": _$(250, 235, 215),
            "aqua marine": _$(127, 255, 212),
            "aqua": c,
            "azure": _$(240, 255, 255),
            "beige": _$(245, 245, 220),
            "bisque": _$(255, 228, 196),
            "black": _$(),
            "blanched almond": _$(255, 235, 205),
            "blue violet": _$(138, 43, 226),
            "blue": _$(0, 0, 255),
            "brown": _$(165, 42, 42),
            "burly wood": _$(222, 184, 135),
            "cadet blue": _$(95, 158, 160),
            "chart reuse": _$(127, 255),
            "chocolate": _$(210, 105, 30),
            "clear": _$(255, 255, 255),
            "coral": _$(255, 127, 80),
            "corn flower blue": _$(100, 149, 237),
            "corn silk": _$(255, 248, 220),
            "crimson": _$(220, 20, 60),
            "cyan": c,
            "dark blue": _$(0, 0, 139),
            "dark cyan": _$(0, 139, 139),
            "dark golden rod": _$(184, 134, 11),
            "dark gray": _$(169, 169, 169),
            "dark green": _$(0, 100),
            "dark khaki": _$(189, 183, 107),
            "dark magenta": _$(139, 0, 139),
            "dark olive green": _$(85, 107, 47),
            "dark orange": _$(255, 140),
            "dark orchid": _$(153, 50, 204),
            "dark red": _$(139),
            "dark salmon": _$(233, 150, 122),
            "dark sea green": _$(143, 188, 143),
            "dark slate blue": _$(72, 61, 139),
            "dark slate gray": _$(47, 79, 79),
            "dark turquoise": _$(0, 206, 209),
            "dark violet": _$(148, 0, 211),
            "deep pink": _$(255, 20, 147),
            "deep sky blue": _$(0, 191, 255),
            "dim gray": _$(105, 105, 105),
            "dodger blue": _$(30, 144, 255),
            "firebrick": _$(178, 34, 34),
            "floral white": _$(255, 250, 240),
            "forest green": _$(34, 139, 34),
            "fuchsia": _$(255, 0, 255),
            "gainsboro": _$(220, 220, 220),
            "ghost white": _$(248, 248, 255),
            "gold": _$(255, 215),
            "golden rod": _$(218, 165, 32),
            "gray": _$(128, 128, 128),
            "green yellow": _$(173, 255, 47),
            "green": _$(0, 128),
            "honeydew": _$(240, 255, 240),
            "hot pink": _$(255, 105, 180),
            "indian red": _$(205, 92, 92),
            "indigo": _$(75, 0, 130),
            "ivory": _$(255, 255, 240),
            "khaki": _$(240, 230, 140),
            "lavender blush": _$(255, 240, 245),
            "lavender": _$(230, 230, 250),
            "lawn green": _$(124, 252),
            "lemon chiffon": _$(255, 250, 205),
            "light blue": _$(173, 216, 230),
            "light coral": _$(240, 128, 128),
            "light cyan": _$(224, 255, 255),
            "light golden rod yellow": _$(250, 250, 210),
            "light gray": _$(211, 211, 211),
            "light green": _$(144, 238, 144),
            "light pink": _$(255, 182, 193),
            "light salmon": _$(255, 160, 122),
            "light sea green": _$(32, 178, 170),
            "light sky blue": _$(135, 206, 250),
            "light slate gray": _$(119, 136, 153),
            "light steel blue": _$(176, 196, 222),
            "light yellow": _$(255, 255, 224),
            "lime green": _$(50, 205, 50),
            "lime": _$(0, 255),
            "lime": _$(0, 255),
            "linen": _$(250, 240, 230),
            "magenta": _$(255, 0, 255),
            "maroon": _$(128),
            "medium aqua marine": _$(102, 205, 170),
            "medium blue": _$(0, 0, 205),
            "medium orchid": _$(186, 85, 211),
            "medium purple": _$(147, 112, 219),
            "medium sea green": _$(60, 179, 113),
            "medium slate blue": _$(123, 104, 238),
            "medium spring green": _$(0, 250, 154),
            "medium turquoise": _$(72, 209, 204),
            "medium violet red": _$(199, 21, 133),
            "midnight blue": _$(25, 25, 112),
            "mint cream": _$(245, 255, 250),
            "misty rose": _$(255, 228, 225),
            "moccasin": _$(255, 228, 181),
            "navajo white": _$(255, 222, 173),
            "navy": _$(0, 0, 128),
            "old lace": _$(253, 245, 230),
            "olive drab": _$(107, 142, 35),
            "olive": _$(128, 128),
            "orange red": _$(255, 69),
            "orange": _$(255, 165),
            "orchid": _$(218, 112, 214),
            "pale golden rod": _$(238, 232, 170),
            "pale green": _$(152, 251, 152),
            "pale turquoise": _$(175, 238, 238),
            "pale violet red": _$(219, 112, 147),
            "papaya whip": _$(255, 239, 213),
            "peach puff": _$(255, 218, 185),
            "peru": _$(205, 133, 63),
            "pink": _$(255, 192, 203),
            "plum": _$(221, 160, 221),
            "powder blue": _$(176, 224, 230),
            "purple": _$(128, 0, 128),
            "red": _$(255),
            "rosy brown": _$(188, 143, 143),
            "royal blue": _$(65, 105, 225),
            "saddle brown": _$(139, 69, 19),
            "salmon": _$(250, 128, 114),
            "sandy brown": _$(244, 164, 96),
            "sea green": _$(46, 139, 87),
            "sea shell": _$(255, 245, 238),
            "sienna": _$(160, 82, 45),
            "silver": _$(192, 192, 192),
            "sky blue": _$(135, 206, 235),
            "slate blue": _$(106, 90, 205),
            "slate gray": _$(112, 128, 144),
            "snow": _$(255, 250, 250),
            "spring green": _$(0, 255, 127),
            "steel blue": _$(70, 130, 180),
            "tan": _$(210, 180, 140),
            "teal": _$(0, 128, 128),
            "thistle": _$(216, 191, 216),
            "tomato": _$(255, 99, 71),
            "transparent": _$(0, 0, 0, 0),
            "turquoise": _$(64, 224, 208),
            "violet": _$(238, 130, 238),
            "wheat": _$(245, 222, 179),
            "white smoke": _$(245, 245, 245),
            "white": _$(255, 255, 255),
            "yellow green": _$(154, 205, 50),
            "yellow": _$(255, 255)
        };
    }

    class CSS_Length extends Number {
        static _parse_(l, rule, r) {
            let tx = l.tx;
            if(l.ty == l.types.num){
                if(l.pk.ty == l.types.id){
                    let id = l.sync().tx;
                    l.n();
                    return new CSS_Length(tx, id);
                }
            }
            return null;
        }

        constructor(v,u){
            super(v);
            this.unit = u;
        }

        get milliseconds(){
            switch(this.unit){
                case("s"):
                    return parseFloat(this) * 1000;
            }

            return parseFloat(this);
        }

        toString(radix){
            return super.toString(radix) + "" + this.unit;
        }

        toJSON(){
            return super.toString() + "" + this.unit;
        }

        get str() {
            return this.toString();
        }
    }

    class CSS_Percentage extends Number {
        static _parse_(l, rule, r) {
            let tx = l.tx;
            if(l.ty == l.types.num){
                if(l.pk.tx == "%"){
                    l.sync().n();
                    return new CSS_Percentage(tx);
                }
            }
            return null;
        }
    }

    class CSS_URL extends WURL {
        static _parse_(l, rule, r) {
            if (l.tx == "url" || l.tx == "uri") {
                l.n().a("(");
                let v = "";
                if (l.ty == l.types.str) {
                    v = l.tx.slice(1,-1);
                    l.n().a(")");
                } else {
                    let p = l.p;
                    while (!p.END && p.n().tx !== ")") { /* NO OP */ }
                    v = p.slice(l);
                    l.sync().a(")");
                }
                return new CSS_URL(v);
            } if (l.ty == l.types.str){
                let v = l.tx.slice(1,-1);
                l.n();
                return new CSS_URL(v);
            }

            return null;
        }
    }

    class CSS_String extends String {
        static _parse_(l, rule, r) {
            if (l.ty == l.types.str) {
                let tx = l.tx;
                l.n();
                return new CSS_String(tx);
            }
            return null;
        }
    }

    class CSS_Id extends String {
        static _parse_(l, rule, r) {
            if (l.ty == l.types.id) {
                let tx = l.tx;
                l.n();
                return new CSS_Id(tx);
            }
            return null;
        }
    }

    /* https://www.w3.org/TR/css-shapes-1/#typedef-basic-shape */

    class CSS_Shape extends Array {
        static _parse_(l, rule, r) {
            if (l.tx == "inset" || l.tx == "circle" || l.tx == "ellipse" || l.tx == "polygon") {
                l.n().a("(");
                let v = "";
                if (l.ty == l.types.str) {
                    v = l.tx.slice(1,-1);
                    l.n().a(")");
                } else {
                    let p = l.p;
                    while (!p.END && p.n().tx !== ")") { /* NO OP */ }
                    v = p.slice(l);
                    l.sync().a(")");
                }
                return new CSS_Shape(v);
            }
            return null;
        }
    }

    class CSS_Number extends Number {
        static _parse_(l, rule, r) {
            let tx = l.tx;
            if(l.ty == l.types.num){
                l.n();
                return new CSS_Number(tx);
            }
            return null;
        }
    }

    class CSS_Bezier extends CBezier {
    	static _parse_(l, rule, r) {

    		let out = null;

    		switch(l.tx){
    			case "cubic":
    				l.n().a("(");
    				let v1 = parseFloat(l.tx);
    				let v2 = parseFloat(l.n().a(",").tx);
    				let v3 = parseFloat(l.n().a(",").tx);
    				let v4 = parseFloat(l.n().a(",").tx);
    				l.a(")");
    				out = new CSS_Bezier(v1, v2, v3, v4);
    				break;
    			case "ease":
    				l.n();
    				out = new CSS_Bezier(0.25, 0.1, 0.25, 1);
    				break;
    			case "ease-in":
    				l.n();
    				out = new CSS_Bezier(0.42, 0, 1, 1);
    				break;
    			case "ease-out":
    				l.n();
    				out = new CSS_Bezier(0, 0, 0.58, 1);
    				break;
    			case "ease-in-out":
    				l.n();
    				out = new CSS_Bezier(0.42, 0, 0.58, 1);
    				break;
    		}

    		return out;
    	}
    }

    const $medh = (prefix) => ({
        _parse_: (l, r, a, n = 0) => (n = CSS_Length._parse_(l, r, a), (prefix > 0) ? ((prefix > 1) ? () => WIN.screen.height <= n : () => WIN.screen.height >= n) : () => WIN.screen.height == n)
    });


    const $medw = (prefix) => ({
        _parse_: (l, r, a, n = 0) => 
            (n = CSS_Length._parse_(l, r, a), (prefix > 0) ? ((prefix > 1) ? () => WIN.screen.width <= n : () => WIN.screen.width >= n) : () => WIN.screen.width == n)
    });

    function CSS_Media_handle(type, prefix) {
        switch (type) {
            case "h":
                return $medh(prefix);
            case "w":
                return $medw(prefix);
        }

        return {
            _parse_: function(a, b, c) {
                debugger;
            }
        }
    }

    /**
     * CSS Type constructors
     * @alias module:wick~internals.css.types.
     * @enum {object}
     */
    const types$1 = {
        color: CSS_Color,
        length: CSS_Length,
        time: CSS_Length,
        flex: CSS_Length,
        angle: CSS_Length,
        frequency: CSS_Length,
        resolution: CSS_Length,
        percentage: CSS_Percentage,
        url: CSS_URL,
        uri: CSS_URL,
        number: CSS_Number,
        id: CSS_Id,
        string: CSS_String,
        shape: CSS_Shape,
        cubic_bezier: CSS_Bezier,
        integer: CSS_Number,

        /* Media parsers */
        m_width: CSS_Media_handle("w", 0),
        m_min_width: CSS_Media_handle("w", 1),
        m_max_width: CSS_Media_handle("w", 2),
        m_height: CSS_Media_handle("h", 0),
        m_min_height: CSS_Media_handle("h", 1),
        m_max_height: CSS_Media_handle("h", 2),
        m_device_width: CSS_Media_handle("dw", 0),
        m_min_device_width: CSS_Media_handle("dw", 1),
        m_max_device_width: CSS_Media_handle("dw", 2),
        m_device_height: CSS_Media_handle("dh", 0),
        m_min_device_height: CSS_Media_handle("dh", 1),
        m_max_device_height: CSS_Media_handle("dh", 2)
    };

    /**
     * CSS Property Definitions https://www.w3.org/TR/css3-values/#value-defs
     * @alias module:wick~internals.css.property_definitions.
     * @enum {string}
     */
    const property_definitions = {
        //https://www.w3.org/TR/2018/REC-css-color-3-20180619//
        
        color: `<color>`,

        opacity: `<alphavalue>|inherit`,


        /*https://www.w3.org/TR/css-backgrounds-3/*/
        /* Background */
        background_color: `<color>`,
        background_image: `<bg_image>#`,
        background_repeat: `<repeat_style>#`,
        background_attachment: `scroll|fixed|local`,
        background_position: `[(<percentage>)|<length>]{1,2}|[top|center|bottom]||[left|center|right]`,
        background_clip: `<box>#`,
        background_origin: `<box>#`,
        background_size: `<bg_size>#`,
        background: `<bg_layer>#,<final_bg_layer>`,



        /* Font */
        font_family: `[[<family_name>|<generic_family>],]*[<family_name>|<generic_family>]`,
        family_name: `<id>||<string>`,
        generic_name: `serif|sans_serif|cursive|fantasy|monospace`,
        font: `[<font_style>||<font_variant>||<font_weight>]?<font_size>[/<line_height>]?<font_family>`,
        font_variant: `normal|small_caps`,
        font_style: ``,

        /*CSS Clipping https://www.w3.org/TR/css-masking-1/#clipping `normal|italic|oblique`, */
        font_size: `<absolute_size>|<relative_size>|<length>|(<percentage>)`,
        absolute_size: `xx_small|x_small|small|medium|large|x_large|xx_large`,
        relative_size: `larger|smaller`,
        font_wight: `normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900`,

        /* Text */
        word_spacing: `normal|<length>`,
        letter_spacing: `normal|<length>`,
        text_decoration: `none|[underline||overline||line-through||blink]`,
        vertical_align: `baseline|sub|super|top|text-top|middle|bottom|text-bottom|(<percentage>)`,
        text_transform: `capitalize|uppercase|lowercase|none`,
        text_align: `left|right|center|justify`,
        text_indent: `<length>|(<percentage>)`,
        line_height: `normal|<length>|(<percentage>)|<number>`,

        /* Box */
        margin: `[<length>|(<percentage>)|auto]{1,4}`,
        margin_top: `<length>|(<percentage>)|auto`,
        margin_right: `<length>|(<percentage>)|auto`,
        margin_bottom: `<length>|(<percentage>)|auto`,
        margin_left: `<length>|(<percentage>)|auto`,

        padding: `[<length>|(<percentage>)|auto]{1,4}`,
        padding_top: `<length>|(<percentage>)|auto`,
        padding_right: `<length>|(<percentage>)|auto`,
        padding_bottom: `<length>|(<percentage>)|auto`,
        padding_left: `<length>|(<percentage>)|auto`,

        /* Border  https://www.w3.org/TR/css-backgrounds-3 */
        border_color: `<color>{1,4}`,
        border_top_color: `<color>`,
        border_right_color: `<color>`,
        border_bottom_color: `<color>`,
        border_left_color: `<color>`,

        border_width: `<line_width>{1,4}`,
        border_top_width: `<line_width>`,
        border_right_width: `<line_width>`,
        border_bottom_width: `<line_width>`,
        border_left_width: `<line_width>`,

        border_style: `<line_style>{1,4}`,
        border_top_style: `<line_style>`,
        border_right_style: `<line_style>`,
        border_bottom_style: `<line_style>`,
        border_left_style: `<line_style>`,

        border_top: `<line_width>||<line_style>||<color>`,
        border_right: `<line_width>||<line_style>||<color>`,
        border_bottom: `<line_width>||<line_style>||<color>`,
        border_left: `<line_width>||<line_style>||<color>`,

        border_radius: `<length_percentage>{1,4}[/<length_percentage>{1,4}]?`,
        border_top_left_radius: `<length_percentage>{1,2}`,
        border_top_right_radius: `<length_percentage>{1,2}`,
        border_bottom_right_radius: `<length_percentage>{1,2}`,
        border_bottom_left_radius: `<length_percentage>{1,2}`,

        border_image: `<border_image_source>||<border_image_slice>[/<border_image_width>|/<border_image_width>?/<border_image_outset>]?||<border_image_repeat>`,
        border_image_source: `none|<image>`,
        border_image_slice: `[<number>|(<percentage>)]{1,4}&&fill?`,
        border_image_width: `[<length_percentage>|<number>|auto]{1,4}`,
        border_image_outset: `[<length>|<number>]{1,4}`,
        border_image_repeat: `[stretch|repeat|round|space]{1,2}`,

        box_shadow: `none|<shadow>#`,

        border: `<line_width>||<line_style>||<color>`,

        width: `<length>|(<percentage>)|auto|inherit`,
        height: `<length>|(<percentage>)|auto|inherit`,
        float: `left|right|none`,
        clear: `left|right|both`,

        /* Classification */

        display: `block|inline|list-item|none`,
        white_space: `normal|pre|nowrap`,
        list_style_type: `disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman|lower-greek|lower-latin|upper-latin|armenian|georgian|lower-alpha|upper-alpha|none|inherit`,
        list_style_image: `<url>|none`,
        list_style_position: `inside|outside`,
        list_style: `[disc|circle|square|decimal|lower-roman|upper-roman|lower-alpha|upper-alpha|none]||[inside|outside]||[<url>|none]`,

        //CSS2 Properties

        /* Box */
        min_width: `<length>|(<percentage>)|inherit`,
        max_width: `<length>|(<percentage>)|none|inherit`,
        line_height: `normal|<number>|<length>|(<percentage>)|inherit`,
        vertical_align: `baseline|sub|super|top|text-top|middle|bottom|text-bottom|(<percentage>)|<length>|inherit`,
        overflow: 'visible|hidden|scroll|auto|inherit',

        clip: '<shape>|auto|inherit',

        /* Visual Effects */
        visibility: `visible|hidden|collapse|inherit`,
        content: `normal|none|[<string>|<uri>|<counter>|attr(<identifier>)|open-quote|close-quote|no-open-quote|no-close-quote]+|inherit`,
        quotas: `[<string><string>]+|none|inherit`,
        counter_reset: `[<identifier><integer>?]+|none|inherit`,
        counter_increment: `[<identifier><integer>?]+|none|inherit`,

        /* CSS3 Animation https://drafts.csswg.org/css-animations-1/ */
        animation: `<single_animation>#`,

        animation_name: `[none|<keyframes_name>]#`,
        animation_duration: `<time>#`,
        animation_timing_function: `<timing_function>#`,
        animation_iteration_count: `<single_animation_iteration_count>#`,
        animation_direction: `<single_animation_direction>#`,
        animation_play_state: `<single_animation_play_state>#`,
        animation_delayed: `<time>#`,
        animation_fill_mode: `<single_animation_fill_mode>#`,





        /* https://drafts.csswg.org/css-transitions-1/ */

        transition: `<single_transition>#`,
        transition_property: `none|<single_transition_property>#`,
        transition_duration: `<time>#`,
        transition_timing_function: `<timing_function>#`,
        transition_delay: `<time>#`,
    };

    /* Properties that are not directly accessible by CSS prop creator */

    const virtual_property_definitions = {

        alphavalue: '<number>',

        box: `border-box|padding-box|content-box`,

        /*https://www.w3.org/TR/css-backgrounds-3/*/

        bg_layer: `<bg_image>||<bg_position>[/<bg_size>]?||<repeat_style>||<attachment>||<box>||<box>`,
        final_bg_layer: `<background_color>||<bg_image>||<bg_position>[/<bg_size>]?||<repeat_style>||<attachment>||<box>||<box>`,
        bg_image: `<url>|none`,
        repeat_style: `repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}`,
        background_attachment: `<attachment>#`,
        bg_size: `<length_percentage>|auto]{1,2}|cover|contain`,
        bg_position: `[[left|center|right|top|bottom|<length_percentage>]|[left|center|right|<length_percentage>][top|center|bottom|<length_percentage>]|[center|[left|right]<length_percentage>?]&&[center|[top|bottom]<length_percentage>?]]`,
        attachment: `scroll|fixed|local`,
        line_style: `none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset`,
        line_width: `thin|medium|thick|<length>`,

        shadow: `inset?&&<length>{2,4}&&<color>?`,

        /* Identifier https://drafts.csswg.org/css-values-4/ */

        identifier: `<id>`,
        custom_ident: `<id>`,

        /* https://drafts.csswg.org/css-timing-1/#typedef-timing-function */

        timing_function: `linear|<cubic_bezier_timing_function>|<step_timing_function>|<frames_timing_function>`,
        cubic_bezier_timing_function: `<cubic_bezier>`,
        step_timing_function: `step-start|step-end|'steps()'`,
        frames_timing_function: `'frames()'`,

        /* https://drafts.csswg.org/css-transitions-1/ */

        single_animation_fill_mode: `none|forwards|backwards|both`,
        single_animation_play_state: `running|paused`,
        single_animation_direction: `normal|reverse|alternate|alternate-reverse`,
        single_animation_iteration_count: `infinite|<number>`,
        single_transition_property: `all|<custom_ident>`,
        single_transition: `[none|<single_transition_property>]||<time>||<timing_function>||<time>`,

        /* CSS3 Animation https://drafts.csswg.org/css-animations-1/ */

        single_animation: `<time>||<timing_function>||<time>||<single_animation_iteration_count>||<single_animation_direction>||<single_animation_fill_mode>||<single_animation_play_state>||[none|<keyframes_name>]`,
        keyframes_name: `<string>`,

        /* CSS3 Stuff */
        length_percentage: `<length>|(<percentage>)`,
        frequency_percentage: `<frequency>|(<percentage>)`,
        angle_percentage: `<angle>|(<percentage>)`,
        time_percentage: `<time>|(<percentage>)`,
        number_percentage: `<number>|(<percentage>)`,

        /*CSS Clipping https://www.w3.org/TR/css-masking-1/#clipping */
        clip_path: `<clip_source>|[<basic_shape>||<geometry_box>]|none`,
        clip_source: `<url>`,
        shape_box: `<box>|margin-box`,
        geometry_box: `<shape_box>|fill-box|stroke-box|view-box`,
        basic_shape: `<CSS_Shape>`,
        ratio: `<integer>/<integer>`
    };

    const media_feature_definitions = {
        width: "<m_width>",
        min_width: "<m_max_width>",
        max_width: "<m_min_width>",
        height: "<m_height>",
        min_height: "<m_min_height>",
        max_height: "<m_max_height>",
        orientation: "portrait  | landscape",
        aspect_ratio: "<ratio>",
        min_aspect_ratio: "<ratio>",
        max_aspect_ratio: "<ratio>",
        resolution: "<length>",
        min_resolution: "<length>",
        max_resolution: "<length>",
        scan: "progressive|interlace",
        grid: "",
        monochrome: "",
        min_monochrome: "<integer>",
        max_monochrome: "<integer>",
        color: "",
        min_color: "<integer>",
        max_color: "<integer>",
        color_index: "",
        min_color_index: "<integer>",
        max_color_index: "<integer>",

    };

    class ValueTerm {

        constructor(value, getPropertyParser, definitions) {

            this._value_ = null;

            const IS_VIRTUAL = { is: false };

            if (!(this._value_ = types$1[value]))
                this._value_ = getPropertyParser(value, IS_VIRTUAL, definitions);

            this._prop_ = "";

            if (!this._value_)
                return new LiteralTerm(value);

            if (this._value_ instanceof NR && IS_VIRTUAL.is)
                this._virtual_ = true;
        }

        _parse_(l, rule, r) {
            if (typeof(l) == "string")
                l = new Lexer(l);

            let rn = { v: null };

            let v = this._value_._parse_(l, rule, rn);

            if (rn.v) {
                if (r)
                    if (r.v) {
                        if (Array.isArray(r.v)) {
                            if (Array.isArray(rn.v) && !this._virtual_)
                                r.v = r.v.concat(rn.v);
                            else
                                r.v.push(rn.v);
                        } else {
                            if (Array.isArray(rn.v) && !this._virtual_)
                                r.v = ([r.v]).concat(rn.v);
                            else
                                r.v = [r.v, rn.v];
                        }
                    } else
                        r.v = (this._virtual_) ? [rn.v] : rn.v;

                if (this._prop_)
                    rule[this._prop_] = rn.v;

                return true;

            } else if (v) {
                if (r)
                    if (r.v) {
                        if (Array.isArray(r.v))
                            r.v.push(v);
                        else
                            r.v = [r.v, v];
                    } else
                        r.v = v;

                if (this._prop_)
                    rule[this._prop_] = v;

                return true;
            } else
                return false;
        }
    }

    class LiteralTerm {

        constructor(value) {
            this._value_ = value;
            this._prop_ = null;
        }

        _parse_(l, rule, r) {

            if (typeof(l) == "string")
                l = new Lexer(l);

            let v = l.tx;
            if (v == this._value_) {
                l.n();

                if (r)
                    if (r.v) {
                        if (Array.isArray(r.v))
                            r.v.push(v);
                        else {
                            let t = r.v;
                            r.v = [t, v];
                        }
                    } else
                        r.v = v;

                if (this._prop_)
                    rule[this._prop_] = v;

                return true;
            }
            return false;
        }
    }

    class SymbolTerm extends LiteralTerm {
        _parse_(l, rule, r) {
            if (typeof(l) == "string")
                l = new Lexer(l);

            if (l.tx == this._value_) {
                l.n();
                return true;
            }

            return false;
        }
    }

    function _getPropertyParser_(property_name, IS_VIRTUAL = { is: false }, definitions = null) {

        let prop = definitions[property_name];

        if (prop) {

            if (typeof(prop) == "string")
                prop = definitions[property_name] = _CreatePropertyParser_(prop, property_name, definitions);

            return prop;
        }

        prop = virtual_property_definitions[property_name];

        if (prop) {

            IS_VIRTUAL.is = true;

            if (typeof(prop) == "string")
                prop = virtual_property_definitions[property_name] = _CreatePropertyParser_(prop, "", definitions);

            return prop;
        }

        return null;
    }


    function _CreatePropertyParser_(notation, name, definitions) {

        const l = new Lexer(notation);

        const important = { is: false };

        let n = _ParseGrammer_(l, definitions);

        if (n instanceof NR && n._terms_.length == 1)
            n = n._terms_[0];

        n._prop_ = name;
        n.IMP = important.is;

        return n;
    }

    function _ParseGrammer_(l, definitions, super_term = false, group = false, need_group = false, and_group = false, important = null) {
        let term, nt;

        while (!l.END) {
            switch (l.ch) {
                case "]":
                    if (term) return term;
                    else 
                        throw new Error("Expected to have term before \"]\"");
                case "[":
                    if (term) return term;
                    term = _ParseGrammer_(l.n(), definitions);
                    l.a("]");
                    break;
                case "&":
                    if (l.pk.ch == "&") {
                        if (and_group)
                            return term;

                        nt = new AND();

                        nt._terms_.push(term);

                        l.sync().n();

                        while (!l.END) {
                            nt._terms_.push(_ParseGrammer_(l, definitions, super_term, group, need_group, true, important));
                            if (l.ch !== "&" || l.pk.ch !== "&") break;
                            l.a("&").a("&");
                        }

                        return nt;
                    }
                case "|":
                    {
                        if (l.pk.ch == "|") {

                            if (need_group)
                                return term;

                            nt = new OR();

                            nt._terms_.push(term);

                            l.sync().n();

                            while (!l.END) {
                                nt._terms_.push(_ParseGrammer_(l, definitions, super_term, group, true, and_group, important));
                                if (l.ch !== "|" || l.pk.ch !== "|") break;
                                l.a("|").a("|");
                            }

                            return nt;

                        } else {
                            if (group) {
                                return term;
                            }

                            nt = new ONE_OF();

                            nt._terms_.push(term);

                            l.n();

                            while (!l.END) {
                                nt._terms_.push(_ParseGrammer_(l, definitions, super_term, true, need_group, and_group, important));
                                if (l.ch !== "|") break;
                                l.a("|");
                            }

                            return nt;
                        }
                    }
                    break;
                case "{":
                    term = _Jux_(term);
                    term.r[0] = parseInt(l.n().tx);
                    if (l.n().ch == ",") {
                        l.n();
                        if (l.n().ch == "}")
                            term.r[1] = Infinity;
                        else {
                            term.r[1] = parseInt(l.tx);
                            l.n();
                        }
                    } else
                        term.r[1] = term.r[0];
                    l.a("}");
                    if (super_term) return term;
                    break;
                case "*":
                    term = _Jux_(term);
                    term.r[0] = 0;
                    term.r[1] = Infinity;
                    l.n();
                    if (super_term) return term;
                    break;
                case "+":
                    term = _Jux_(term);
                    term.r[0] = 1;
                    term.r[1] = Infinity;
                    l.n();
                    if (super_term) return term;
                    break;
                case "?":
                    term = _Jux_(term);
                    term.r[0] = 0;
                    term.r[1] = 1;
                    l.n();
                    if (super_term) return term;
                    break;
                case "#":
                    term = _Jux_(term);
                    term._terms_.push(new SymbolTerm(","));
                    term.r[0] = 1;
                    term.r[1] = Infinity;
                    l.n();
                    if (l.ch == "{") {
                        term.r[0] = parseInt(l.n().tx);
                        term.r[1] = parseInt(l.n().a(",").tx);
                        l.n().a("}");
                    }
                    if (super_term) return term;
                    break;
                case "<":

                    if (term) {
                        if (term instanceof NR && term.isRepeating()) term = _Jux_(new NR, term);
                        let v = _ParseGrammer_(l, definitions, true);
                        term = _Jux_(term, v);
                    } else {
                        let v = new ValueTerm(l.n().tx, _getPropertyParser_, definitions);
                        l.n().a(">");
                        term = v;
                    }
                    break;
                case "!":
                    /* https://www.w3.org/TR/CSS21/cascade.html#important-rules */

                    l.n().a("important");
                    important.is = true;
                    break;
                default:
                    if (term) {
                        if (term instanceof NR && term.isRepeating()) term = _Jux_(new NR, term);
                        let v = _ParseGrammer_(l, definitions, true);
                        term = _Jux_(term, v);
                    } else {
                        let v = (l.ty == l.types.symbol) ? new SymbolTerm(l.tx) : new LiteralTerm(l.tx);
                        l.n();
                        term = v;
                    }
            }
        }
        return term;
    }

    function _Jux_(term, new_term = null) {
        if (term) {
            if (!(term instanceof NR)) {
                let nr = new NR();
                nr._terms_.push(term);
                term = nr;
            }
            if (new_term) term._terms_.push(new_term);
            return term;
        }
        return new_term;
    }

    /**
     * The empty CSSRule instance
     * @alias module:wick~internals.css.empty_rule
     */
    const er = OB.freeze(new CSSRule());

    class _selectorPart_ {
        constructor() {
            this.e = "";
            this.ss = [];
            this.c = "";
        }
    }

    class _mediaSelectorPart_ {
        constructor() {
            this.id = "";
            this.props = {};
            this.c = "";
        }
    }

    /**
     * Container for all rules found in a CSS string or strings.
     *
     * @memberof module:wick~internals.css
     * @alias CSSRootNode
     */
    class CSSRootNode {

        constructor(_med_ = []) {

            this.promise = null;

            /**
             * Media query selector
             */
            this._med_ = _med_;

            /**
             * All selectors indexed by their value
             */
            this._selectors_ = {};

            /**
             * All selectors in order of appearance
             */
            this._sel_a_ = [];

            /**
             * rules falling under different media, these are stored as addition CSSRootNodes
             */
            this._media_ = [];

            /**
             * The next set of CSS rules to lookup.
             */
            this._next_ = null;

            this.resolves = [];
            this.res = null;


            this.pending_build = 0;
        }

        _resolveReady_(res, rej) {
            if (this.pending_build > 0)
                this.resolves.push(res);
            res(this);
        }

        _setREADY_() {
            if (this.pending_build < 1) {
                for (let i = 0, l = this.resolves; i < l; i++)
                    this.resolves[i](this);
                this.resolves.length = 0;
                this.res = null;
            }
        }

        _READY_() {
            if (!this.res)
                this.res = this._resolveReady_.bind(this);

            return new Promise(this.res);
        }

        /**
         * Creates a new instance of the object with same properties as the original.
         * @return     {CSSRootNode}  Copy of this object.
         * @public
         */
        clone() {
            let rn = new this.constructor();

            rn._selectors_ = this._selectors_;
            rn._sel_a_ = this._sel_a_;
            rn._media_ = this._media_;

            return rn;
        }

        /**
         * Gets the media.
         * @return     {Object}  The media.
         * @public
         */
        getMedia() {
            let start = this;

            this._media_.forEach((m) => {
                if (m._med_) {
                    let accept = true;
                    for (let i = 0, l = m._med_.length; i < l; i++) {
                        let ms = m._med_[i];

                        if (ms.props) {
                            for (let n in ms.props) {
                                if (!ms.props[n]())
                                    accept = false;
                            }
                        }

                        //if(not)
                        //    accept = !accept;

                        if (accept)
                            (m._next_ = start, start = m);


                    }
                }
            });

            return start;
        }

        /**
         * Hook method for hijacking the property parsing function. Return true if default property parsing should not take place
         * @param      {Lexer}   value_lexer    The value lexer
         * @param      {<type>}   property_name  The property name
         * @param      {<type>}   rule           The rule
         * @return     {boolean}  The property hook.
         */
        _getPropertyHook_(value_lexer, property_name, rule) {
            return false;
        }

        /**
         * Parses properties
         * @param      {Lexer}  lexer        The lexer
         * @param      {<type>}  rule         The rule
         * @param      {<type>}  definitions  The definitions
         */
        _GetProperty_(lexer, rule, definitions) {
            const name = lexer.tx.replace(/\-/g, "_");

            lexer.n().a(":");
            //allow for short circuit < | > | =

            const p = lexer.pk;

            while ((p.ch !== "}" && p.ch !== ";")) {
                //look for 
                p.n();
            }

            const out_lex = lexer.copy();
            lexer.sync();
            out_lex.fence(p);

            if (!this._getPropertyHook_(out_lex, name, rule)) {
                try {
                    const IS_VIRTUAL = { is: false };
                    const parser = _getPropertyParser_(name, IS_VIRTUAL, definitions);
                    if (parser && !IS_VIRTUAL.is) {
                        if (!rule.props) rule.props = {};
                        parser._parse_(out_lex, rule.props);
                    } else
                        //Need to know what properties have not been defined
                        console.warn(`Unable to get parser for css property ${name}`);
                } catch (e) {
                    console.log(e);
                }
            }

            if (lexer.ch == ";") lexer.n();
        }


        _applyProperties_(lexer, rule) {
            while (!lexer.END && lexer.tx !== "}")
                this._GetProperty_(lexer, rule, property_definitions);

            lexer.n();
        }


        /**
         * Used to match selectors to elements
         * @param      {ele}   ele       The ele
         * @param      {string}   criteria  The criteria
         * @return     {boolean}  { description_of_the_return_value }
         * @private
         */
        _matchCriteria_(ele, criteria) {
            if (criteria.e && ele.tagName !== criteria.e.toUpperCase())
                return false;
            outer:
                for (let i = 0, l = criteria.ss.length; i < l; i++) {
                    let ss = criteria.ss[i];
                    switch (ss.t) {
                        case "attribute":
                        
                            let lex = new Lexer(ss.v);
                            if(lex.ch=="[" && lex.pk.ty == lex.types.id){
                                let id = lex.sync().tx;
                                let attrib = ele.getAttribute(id);
                                if(!attrib) return;
                                if(lex.n().ch == "="){
                                    let value = lex.n().tx;
                                    if(attrib !== value) return false;
                                }
                            }
                            break;
                        case "pseudo":
                            debugger;
                            break;
                        case "class":
                            let class_list = ele.classList;
                            for (let j = 0, jl = class_list.length; j < jl; j++) {
                                if (class_list[j] == ss.v)
                                    continue outer;
                            }
                            return false;
                        case "id":
                            if (ele.id !== ss.v)
                                return false;
                    }
                }

            return true;
        }

        /**
         * Retrieves the set of rules from all matching selectors for an element.
         * @param      {HTMLElement}  element - An element to retrieve CSS rules.
         * @public
         */
        getApplicableRules(element, rule = new CSSRule()) {
            outer: for (let j = 0, jl = this._sel_a_.length; j < jl; j++) {
                let ancestor = element;
                let selector = this._sel_a_[j];
                let sa = selector.a;
                let criteria = null;
                inner:
                    for (let i = 0, l = sa.length; i < l; i++) {
                        criteria = sa[i];
                        switch (criteria.c) {
                            case "child":
                                if (!(ancestor = ancestor.parentElement) || !this._matchCriteria_(ancestor, criteria))
                                    continue outer;
                                break;
                            case "preceded":
                                while ((ancestor = ancestor.previousElementSibling))
                                    if (this._matchCriteria_(ancestor, criteria))
                                        continue inner;
                                continue outer;
                            case "immediately preceded":
                                if (!(ancestor = ancestor.previousElementSibling) || !this._matchCriteria_(ancestor, criteria))
                                    continue outer;
                                break;
                            case "descendant":
                                while ((ancestor = ancestor.parentElement))
                                    if (this._matchCriteria_(ancestor, criteria))
                                        continue inner;
                                continue outer;
                            default:
                                if (!this._matchCriteria_(ancestor, criteria))
                                    continue outer;
                        }
                    }
                rule.merge(selector.r);
            }

            return (this._next_) ? this._next_.getApplicableRules(element, rule) : rule;
        }

        /**
         * Gets the rule matching the selector
         * @param      {string}  string  The string
         * @return     {CSSRule}  The combined set of rules that match the selector.
         */
        getRule(string) {
            let selector = this._selectors_[string];

            if (selector)

                return selector.r;

            return er;
        }

        /**
         * Parses CSS string
         * @param      {Lexer} - A Lexical tokenizing object supporting methods found in {@link Lexer}
         * @param      {(Array|CSSRootNode|Object|_mediaSelectorPart_)}  root    The root
         * @return     {Promise}  A promise which will resolve to a CSSRootNode
         * @private
         */
        _parse_(lexer, root, res = null, rej = null) {
            return new Promise((res, rej) => {

                if (!root && root !== null) {
                    root = this;
                    this.pending_build++;
                }

                let selectors = [],
                    l = 0;
                while (!lexer.END) {
                    switch (lexer.ch) {
                        case "@":
                            lexer.n();

                            switch (lexer.tx) {
                                case "media": //Ignored at this iteration /* https://drafts.csswg.org/mediaqueries/ */
                                    //create media query selectors
                                    let _med_ = [],
                                        sel = null,
                                        media_root = null;
                                    while (!lexer.END && lexer.n().ch !== "{") {

                                        if (!sel) sel = new _mediaSelectorPart_();

                                        if (lexer.ch == ",")
                                            _med_.push(sel), sel = null;
                                        else if (lexer.ch == "(") {
                                            let start = lexer.n().off;

                                            while (!lexer.END && lexer.ch !== ")") lexer.n();

                                            let out_lex = lexer.copy();
                                            out_lex.off = start;
                                            out_lex.tl = 0;
                                            out_lex.n().fence(lexer);

                                            this._GetProperty_(out_lex, sel, media_feature_definitions);

                                            if (lexer.pk.tx.toLowerCase() == "and")
                                                lexer.sync();
                                        } else {
                                            let id = lexer.tx.toLowerCase(),
                                                condition = "";
                                            if (id === "only" || id === "not")
                                                (condition = id, id = lexer.n().tx);

                                            sel.c = condition;

                                            sel.id = id;

                                            if (lexer.pk.tx.toLowerCase() == "and")
                                                lexer.sync();
                                        }
                                    }
                                    //debugger
                                    lexer.a("{");

                                    if (sel)
                                        _med_.push(sel);


                                    if (_med_.length == 0)
                                        this._parse_(lexer, null); // discard results
                                    else {
                                        this._parse_(lexer, (media_root = new this.constructor(_med_)));
                                        this._media_.push(media_root);
                                    }



                                    continue;
                                case "import":
                                    /* https://drafts.csswg.org/css-cascade/#at-ruledef-import */
                                    let type;
                                    if (type = types$1.url._parse_(lexer.n())) {

                                        lexer.a(";");
                                        /**
                                         * The {@link CSS_URL} incorporates a fetch mechanism that returns a Promise instance.
                                         * We use that promise to hook into the existing promise returned by CSSRoot#_parse_,
                                         * executing a new _parse_ sequence on the fetched string data using the existing CSSRoot instance,
                                         * and then resume the current _parse_ sequence.
                                         * @todo Conform to CSS spec and only _parse_ if @import is at the top of the CSS string.
                                         */
                                        return type.fetchText().then((str) =>

                                            //Successfully fetched content, proceed to _parse_ in the current root.
                                            //let import_lexer = ;

                                            res(this._parse_(new Lexer(str, true), this).then((r) => this._parse_(lexer, r)))

                                            //_Parse_ returns Promise. 
                                            // return;
                                        ).catch((e) =>
                                            res(this._parse_(lexer))
                                        );
                                    } else {
                                        //Failed to fetch resource, attempt to find the end to of the import clause.
                                        while (!lexer.END && lexer.n().tx !== ";") {}                                    lexer.n();
                                    }
                            }
                            break;

                        case "/":
                            lexer.comment(true);
                            break;
                        case "}":
                            lexer.n();
                            return;
                        case "{":

                            let rule = new CSSRule();

                            this._applyProperties_(lexer.n(), rule);

                            for (let i = -1, sel = null; sel = selectors[++i];)
                                if (sel.r)
                                    sel.r.merge(rule);
                                else
                                    sel.r = rule;


                            selectors.length = l = 0;

                            continue;
                    }

                    if (root) {
                        let selector = this.__parseSelector__(lexer, this);
                        if (selector) {

                            if (!root._selectors_[selector.v]) {
                                l = selectors.push(selector);
                                root._selectors_[selector.v] = selector;
                                root._sel_a_.push(selector);
                            } else
                                l = selectors.push(root._selectors_[selector.v]);
                        }
                    }
                }

                res(this);

                this._setREADY_();

                return this;
            });
        }

        /** 
        Parses a selector up to a token '{', creating or accessing necessary rules as it progresses. 

        Reference: https://www.w3.org/TR/selectors-3/ 
        https://www.w3.org/TR/css3-mediaqueries/
        https://www.w3.org/TR/selectors-3/

        @param {Lexer} - A Lexical tokenizing object supporting methods found in {@link Lexer}.

        @protected

        */
        __parseSelector__(lexer) {
            let selector_array = [];

            let start = lexer.pos;



            let sel = new _selectorPart_();

            while (!lexer.END) {

                if (!sel) sel = new _selectorPart_();
                switch (lexer.tx) {
                    case ",":
                        lexer.n();
                    case "{":
                        selector_array.unshift(sel);
                        return new CSSSelector(lexer.s(start).trim(), selector_array);
                    case "[":
                        let p = lexer.pk;
                        while (!p.END && p.n().tx !== "]") {}                    p.a("]");
                        if (p.END) throw new _Error_("Unexpected end of input.");
                        sel.ss.push({
                            t: "attribute",
                            v: p.s(lexer)
                        });
                        lexer.sync();
                        break;
                    case ":":
                        sel.ss.push({
                            t: "pseudo",
                            v: lexer.n().tx
                        });
                        _eID_(lexer);
                        lexer.n();
                        break;
                    case ".":
                        sel.ss.push({
                            t: "class",
                            v: lexer.n().tx
                        });
                        _eID_(lexer);
                        lexer.n();
                        break;
                    case "#":
                        sel.ss.push({
                            t: "id",
                            v: lexer.n().tx
                        });
                        _eID_(lexer);
                        lexer.n();
                        break;
                    case "*":
                        lexer.n();
                        break;
                    case ">":
                        sel.c = "child";
                        selector_array.unshift(sel);
                        sel = null;
                        lexer.n();
                        break;
                    case "~":
                        sel.c = "preceded";
                        selector_array.unshift(sel);
                        sel = null;
                        lexer.n();
                        break;
                    case "+":
                        sel.c = "immediately preceded";
                        selector_array.unshift(sel);
                        sel = null;
                        lexer.n();
                        break;
                    default:
                        if (sel.e) {
                            sel.c = "descendant";
                            selector_array.unshift(sel);
                            sel = null;
                        } else {
                            sel.e = lexer.tx;
                            _eID_(lexer);
                            lexer.n();
                        }
                        break;
                }
            }

            return null;
        }
    }

    /*
     * Expecting ID error check.
     */
    const _err_ = "Expecting Identifier";
    /**
     * Checks to make sure token is an Identifier.
     * @param      {Lexer} - A Lexical tokenizing object supporting methods found in {@link Lexer}.
     * @alias module:wick~internals.css.elementIsIdentifier
     */
    function _eID_(lexer) {
        if (lexer.ty != lexer.types.id) lexer.throw(_err_);
    }

    /**
     * Builds a CSS object graph that stores `selectors` and `rules` pulled from a CSS string. 
     * @function
     * @param {string} css_string - A string containing CSS data.
     * @param {string} css_string - An existing CSSRootNode to merge with new `selectors` and `rules`.
     * @return {Promise} A `Promise` that will return a new or existing CSSRootNode.
     * @memberof module:wick.core
     * @alias css
     */
    const CSSParser = (css_string, root = null) => (root = (!root || !(root instanceof CSSRootNode)) ? new CSSRootNode() : root, root._parse_(new Lexer(css_string, true)));

    class IOBase {

        constructor(parent) {
            parent._ios_.push(this);
            this.parent = parent;
        }

        _destroy_() {
            this.parent.removeIO(this);
            this.parent = null;
        }

        _down_() {}
        _up_(value, meta) { this.parent._up_(value, meta); }
    }

    /**
     *   The IO is the last link in the Source chain. It is responsible for putting date into the DOM through the element it binds to.
     *   @param {Source} tap - The tap {@link Source}, used internally to build a hierarchy of Sources.
     *   @param {Object} data - An object containing HTMLELement attribute values and any other values produced by the template parser.
     *   @param {Presets} presets - An instance of the {@link Presets} object.
     *   @param {HTMLElement} element - The HTMLElement that the IO will _bind_ to.
     *   @memberof module:wick.core.source
     *   @alias IO
     *   @extends IOBase
     */
    class IO extends IOBase {

        constructor(source, errors, tap, element = null) {
            super(tap);
            //Appending the value to a text node prevents abuse from insertion of malicious DOM markup. 
            this.ele = element;
        }

        _destroy_() {
            this.ele = null;
            super._destroy_();
        }

        _down_(value) {
            this.ele.data = value;
        }
    }

    /**
        This IO object will _update_ the attribute value of the watched element, using the "prop" property to select the attribute to _update_.
    */
    class AttribIO extends IOBase {
        constructor(source, errors, tap, attr, element) {
            super(tap);

            this.attrib = attr;
            this.ele = element;
        }

        _destroy_() {
            this.ele = null;
            this.attrib = null;
            super._destroy_();
        }

        /**
            Puts data into the watched element's attribute. The default action is to simply _update_ the attribute with data._value_.  
        */
        _down_(value) {
            this.ele.setAttribute(this.attrib, value);
        }
    }

    class InputIO extends IOBase {

        constructor(source, errors, tap, element) {

            super(tap);

            this.ele = element;

            this.event = (e) => { this.parent._up_(e.target.value, { event: e }); };

            this.ele.addEventListener("input", this.event);
        }

        _destroy_() {
            this.ele.removeEventListener("input", this.event);
            this.ele = null;
            this.event = null;
            this.attrib = null;
        }

        _down_(value) {
            this.ele.value = value;
        }
    }

    class BindIO extends IOBase {

        constructor(source, errors, tap) {
            super(tap);
            this._value_ = null;
            this.child = null;
        }

        _destroy_() {
            this._value_ = null;
            if (this.child) this.child._destroy_();
            this.child = null;
            super._destroy_();
        }

        /**
            Puts data into the watched element's attribute. The default action is to simply _update_ the attribute with data._value_.  
        */
        _down_(value) {
            this._value_ = value;
            this.child._down_();
        }
    }

    class TemplateString extends IOBase {

        constructor(source, errors, taps, element, binds) {

            super(source);
            this._SCHD_ = 0;
            this.binds = [];
            this.ele = element;
            this._setBindings_(source, errors, taps, binds);
        }

        _destroy_() {
            for (var i = 0; i < this.binds.length; i++)
                this.binds[i]._destroy_();
            this._SCHD_ = 0;
            this.binds = null;
            this.ele = null;
            super._destroy_();
        }

        _setBindings_(source, errors, taps, binds) {
            for (var i = 0; i < binds.length; i++) {
                let bind = binds[i];

                switch (bind.type) {
                    case 0: //DYNAMIC_BINDING_ID
                        let new_bind = new BindIO(source, errors, source.getTap(bind.tap_name), bind);
                        this.binds.push(new_bind);
                        new_bind.child = this;
                        //this.binds.push(msg._bind_(source, errors, taps, this));
                        break;
                    case 1: //RAW_VALUE_BINDING_ID
                        this.binds.push(bind);
                        break;
                    case 2: //TEMPLATE_BINDING_ID
                        if (bind._bindings_.length < 1) // Just a variable less expression.
                            this.binds.push({ _value_: msg.func() });
                        else
                            this.binds.push(bind._bind_(source, errors, taps, this));
                        break;
                }
            }
            this._down_();
        }

        get data() {}
        set data(v) { scheduler.queueUpdate(this); }

        _down_() {
            scheduler.queueUpdate(this);
        }

        _scheduledUpdate_() {

            let str = [];

            for (let i = 0; i < this.binds.length; i++)
                str.push(this.binds[i]._value_);

            this.ele.data = str.join('');
        }
    }

    class AttribTemplate extends TemplateString {

        constructor(source, errors, taps, attr, element, binds) {
            super(source, errors, taps, element, binds);
            this.attrib = attr;
        }

        _destroy_() {
            this.attrib = null;
            super._destroy_();
        }

        _scheduledUpdate_() {

            let str = [];

            for (let i = 0; i < this.binds.length; i++)
                str.push(this.binds[i]._value_);

            this.ele.setAttribute(this.attrib, str.join(''));
        }
    }

    function replaceString(e){
        return e[1].toUpperCase();
    }

    function toCamel(string){
        let str = string.replace(/(?:[-_])([a-z])/g, replaceString);
        return str
    }
    class CSSRawValue {

        constructor(name, prop = null) {
            this._name_ = toCamel(name);
            this._value_ = "";

            if (Array.isArray(prop))
                this._value_ = prop.join(" ");
            else
                this._value_ = prop.toString();
        }

        get UPDATED() { return false; }
        set UPDATED(v) {}
    }

    class CSSRuleTemplateString {
        constructor(source, errors, taps, binds, name) {
            this.binds = [];
            this._setBindings_(source, errors, taps, binds);
            this._ios_ = [];
            this._value_ = "";
            this._name_ = toCamel(name);
        }

        _destroy_() {
            for (let i = 0, l = this.binds.length; i < l; i++)
                this.binds[i]._destroy_();
            this.binds = null;
            for (let i = 0; i < this._ios_.length; i++)
                this._ios_[i]._destroy_();
            this._ios_ = null;
            this._value_ = null;
            this._name_ = null;
        }

        _setBindings_(source, errors, taps, binds) {
            for (var i = 0; i < binds.length; i++) {
                let bind = binds[i];

                switch (bind.type) {
                    case 0: //DYNAMIC_BINDING_ID
                        let new_bind = new BindIO(source, errors, source.getTap(bind.tap_name), bind);
                        this.binds.push(new_bind);
                        new_bind.child = this;
                        //this.binds.push(msg._bind_(source, errors, taps, this));
                        break;
                    case 1: //RAW_VALUE_BINDING_ID
                        this.binds.push(bind);
                        break;
                    case 2: //TEMPLATE_BINDING_ID
                        if (bind._bindings_.length < 1) // Just a variable less expression.
                            this.binds.push({ _value_: msg.func() });
                        else
                            this.binds.push(bind._bind_(source, errors, taps, this));
                        break;
                }
            }
            this._down_();
        }

        get data() {}
        set data(v) { scheduler.queueUpdate(this); }

        _down_() { scheduler.queueUpdate(this); }

        _scheduledUpdate_() {

            let str = [];

            for (let i = 0; i < this.binds.length; i++)
                str.push(this.binds[i]._value_);
            this._value_ = str.join(' ');
            for (let i = 0, l = this._ios_.length; i < l; i++)
                this._ios_[i]._updateRule_();
        }

        addIO(io) { this._ios_.push(io); }
        removeIO(io) {
            for (let i = 0; i < this._ios_.length; i++) {
                let own_io = this._ios_[i];
                if (own_io == io) return void this._ios_.splice(i, 1);
            }
        }
    }


    class StyleIO extends IOBase {
        constructor(source, errors, taps, element, props = []) {

            super(source);

            this.ele = element;

            this.props = [];

            this._initializeProps_(source, errors, taps, props);

            this._scheduledUpdate_();
        }

        _destroy_() {
            this._template_text_ = null;
            this._rules_text_ = null;
            this.ele = null;
            this.props = null;
            super._destroy_();
        }

        _setRule_(rule){
            let props = rule.props;

            this.props.length = 0;

            for (let name in props) {
                let prop = props[name];

                let wick_prop = (prop._wick_type_ > 0) ? prop.bind(this.parent, [], {}, this) : new CSSRawValue(name, prop);

                this.props.push(wick_prop);

                scheduler.queueUpdate(this);
            }
        }

        _initializeProps_(source, errors, taps, props) {

            for (let i = 0, l = props.length; i < l; i++) {
                let prop = props[i];
                if (prop._wick_type_ == 1) {
                    this.props.push(props[i]._bind_(source, errors, taps, this));
                } else
                    this.props.push(prop);
            }
        }

        _updateRule_() { scheduler.queueUpdate(this); }

        get data() {}
        set data(data) { scheduler.queueUpdate(this); }

        _scheduledUpdate_() {
            for (let i = 0; i < this.props.length; i++) {
                let prop = this.props[i];
                this.ele.style[prop._name_] = prop._value_;
            }
        }
    }

    /******************** Expressions **********************/

    class ExpressionIO extends TemplateString {

        constructor(source, errors, taps, element, binds, func) {
            super(source, errors, taps, element, binds);
            this._expr_function_ = func;
            this._value_ = null;
            this._filter_expression_ = null;
            this._bl_ = this.binds.length;
        }

        _destroy_(){
            this._expr_function_ = null;
            this._value_ = null;
            this._filter_expression_ = null;
            this._bl_ = null;
            super._destroy_();
        }

        set _IS_A_FILTER_(v) {
            if (v == true) {
                var model_arg_index = -1;
                var index_arg_index = -1;

                for (let i = 0, l = this._bl_; i < l; i++) {
                    let bind = this.binds[i];
                    if (bind.parent._prop_ == "model" || bind.parent._prop_ == "m") {
                        model_arg_index = i;
                    }

                    if (bind.parent._prop_ == "index" || bind.parent._prop_ == "i") {
                        index_arg_index = i;
                    }
                }

                this._filter_expression_ = (source, index) => {
                    const args = [];
                    
                    for (let i = 0, l = this._bl_; i < l; i++) {
                        if (i == model_arg_index) { args.push(source.model); continue; }
                        if (i == index_arg_index) { args.push(index); continue; }
                        args.push(this.binds[i]._value_);
                    }

                    return this._expr_function_.apply(null, args);
                };
            }
        }

        get _IS_A_FILTER_() { return typeof(this._filter_expression_) == "function"; }

        _scheduledUpdate_() {
            if (this._IS_A_FILTER_) {
                this.ele.update();
            } else {
                const args = [];
                
                for (let i = 0; i < this.binds.length; i++){
                    if(this.binds[i]._value_ === null) return;
                    args.push(this.binds[i]._value_);
                }

                this._value_ = this._expr_function_.apply(null, args);
                this.ele.data = this._value_;
            }
        }
    }

    class InputExpresionIO extends ExpressionIO{
        _scheduledUpdate_() {
            if (this._IS_A_FILTER_) {
                this.ele.update();
            } else {
                const args = [];
                for (let i = 0; i < this.binds.length; i++)
                    args.push(this.binds[i]._value_);

                this._value_ = this._expr_function_.apply(null, args);
                this.ele.value = this._value_;
            }
        }
    }

    class EventIO {
        constructor(source, errors, taps, element, event, event_bind, msg) {

            if (typeof element[event] == "undefined") {
                errors.push(new Error(`Can not bind event ${event} to element ${element}`));
                return;
            }

            this.parent = source;
            source._ios_.push(this);

            this._ele_ = element;
            this._event_bind_ = new IOBase(taps[event_bind.tap_id]);
            this._event_ = event.replace("on","");
            this._msg_ = null;
            this.data = null;

            if (msg) {
                switch (msg.type) {
                    case 0: //DYNAMIC_BINDING_ID
                        this._msg_ = msg._bind_(source, errors, taps, this);
                        break;
                    case 1: //RAW_VALUE_BINDING_ID
                        this.data = msg.txt;
                        break;
                    case 2: //TEMPLATE_BINDING_ID
                        if (msg._bindings_.length < 1) // Just a variable less expression.
                            this.data = msg.func();
                        else
                            this._msg_ = msg._bind_(source, errors, taps, this);
                        break;
                }
            }
            this._event_handle_ = (e) => this._handleEvent_(e);
            this._ele_.addEventListener(this._event_, this._event_handle_ );
        }

        /**
         * Removes all references to other objects.
         * Calls _destroy_ on any child objects.
         */
        _destroy_() {
            if (this._msg_)
                this._msg_._destroy_();
            this._event_bind_._destroy_();
            this._msg_ = null;
            this._ele_.removeEventListener(this._event_, this._event_handle_ );
            this._ele_ = null;
            this._event_ = null;
            this.parent.removeIO(this);
            this.parent = null;
            this.data = null;
        }

        _handleEvent_(e) {
            e.preventDefault();
            e.stopPropagation();
            this._event_bind_._up_(this.data, { event: e });
            return false;
        }
    }

    class ScriptIO extends IOBase {
        constructor(source, errors, tap, binding) {
            
            let func;

            try {
                if (binding._func_) {
                    func = binding._func_;
                } else {
                    func = Function("value", "event", "model", "emit", "presets", "static", "src", binding.val);
                    binding._func_ = func;
                }
            } catch (e) {
                errors.push(e);
                return;
            }

            super(tap);
            this._func_ = func;
            this._source_ = source;
            this._bound_emit_function_ = this._emit_.bind(this);
            this.meta = null;
        }

        /**
         * Removes all references to other objects.
         * Calls _destroy_ on any child objects.
         */
        _destroy_() {
            this._func_ = null;
            this._source_ = null;
            this._bound_emit_function_ = null;
            this._meta = null;

        }

        _down_(value, meta = {event:null}) {
            this.meta = meta;
            const src = this._source_;
            this._func_(value, meta.event, src._model_, this._bound_emit_function_, src._presets_, src._statics_, src);
        }

        _emit_(name, value) {
            if (
                typeof(name) !== "undefined" &&
                typeof(value) !== "undefined"
            ) {
                this._source_._upImport_(name, value, this.meta);
            }
        }
    }

    const DYNAMIC_BINDING_ID = 0;
    const RAW_VALUE_BINDING_ID = 1;
    const TEMPLATE_BINDING_ID = 2;

    const ATTRIB = 1;
    const TEXT$1 = 4;
    const INPUT = 5;
    const SCRIPT = 6;
    const EVENT = 7;

    /**
     * Binding builder for expressions
     *
     * @class      ExpressionBinding (name)
     */
    class EventBinding {
        constructor(prop) {
            this.bind = null;
            this._event_ = prop;
        }

        _bind_(source, errors, taps, element, eventname) {
            return new EventIO(source, errors, taps, element, eventname, this._event_, this.bind);
        }

        get _bindings_() {
            if (this.bind) {
                if (this.bind.type == TEMPLATE_BINDING_ID)
                    return [...this.bind._bindings_, this._event_];
                else
                    return [this.bind, this._event_];
            }
            return [this._event_];
        }
        set _bindings_(v) {}

        get type() {
            return TEMPLATE_BINDING_ID;
        }
        set type(v) {}
    }

    /**
     * Binding builder for expressions
     *
     * @class      ExpressionBinding (name)
     */
    class ExpressionBinding {
        constructor(binds, func) {
            this._bindings_ = binds;
            this.func = func;
        }

        _bind_(source, errors, taps, element) {
            
            switch (this.method) {
                case INPUT:
                    return new InputExpresionIO(source, errors, taps, element, this._bindings_, this.func);
                default:
                    return new ExpressionIO(source, errors, taps, element, this._bindings_, this.func);
            }
        }

        get type() {
            return TEMPLATE_BINDING_ID;
        }
        set type(v) {}
    }


    class DynamicBinding {

        constructor() {
            this.tap_name = "";
            this.tap_id = 0;
            this.val = "";
            this._func_ = null;
            this.method = 0;
        }

        _bind_(source, errors, taps, element) {
            let tap = taps[this.tap_id];
            switch (this.method) {
                case INPUT:
                    return new InputIO(source, errors, tap, element);
                case ATTRIB:
                    return new AttribIO(source, errors, tap, this.val, element);
                case SCRIPT:
                    return new ScriptIO(source, errors, tap, this);
                default:
                    return new IO(source, errors, tap, element);
            }
        }

        get type() {
            return DYNAMIC_BINDING_ID;
        }
        set type(v) {}
    }

    class RawValueBinding {
        constructor(txt) {
            this.txt = txt;
            this.method = 0;
        }

        _bind_(source, errors, taps, element, prop = "") {

            switch (this.method) {
                case TEXT$1:
                    element.data = this.txt;
                    break;
                case ATTRIB:
                    element.setAttribute(prop, this.txt);
            }
        }
        get _value_() { return this.txt; }
        set _value_(v) {}
        get type() { return RAW_VALUE_BINDING_ID; }
        set type(v) {}
    }

    /**
     * Basic JS Parser Kludge to get legitimate foreign identifiers from expressions.
     * This could later be expanded into a full JS parser to generate proper JS ASTs.
     * @class      JSExpressionIdentifiers 
     * @param      {Lexer}  lex     The lex
     * @return     {Object}  { description_of_the_return_value }
     */
    function JSExpressionIdentifiers(lex) {
        let _identifiers_ = [];
        let model_cache = {};

        let IN_OBJ = false,
            CAN_BE_ID = true;
        while (!lex.END) {
            
            switch (lex.ty) {
                case lex.types.id:
                    if (!IN_OBJ || CAN_BE_ID) {
                        let id = lex.tx;
                        if (!model_cache[id]) {
                            _identifiers_.push(lex.tx);
                            model_cache[id] = true;
                        }
                    }   
                    break;
                case lex.types.op:
                case lex.types.sym:
                case lex.types.ob:
                case lex.types.cb:
                    switch (lex.ch) {
                        case "+":
                        case ">":
                        case "<":
                        case "/":
                        case "*":
                        case "-":
                            CAN_BE_ID = true;
                            break;
                        case "[":
                            IN_OBJ = false;
                            CAN_BE_ID = true;
                            break;
                        case "{":
                        case ".": //Property Getters
                            CAN_BE_ID = false;
                            IN_OBJ = true;
                            break;
                        case "]":
                        case ";":
                        case "=":
                        case "}":
                        case "(":
                            IN_OBJ = false;
                            break;
                        case ",":
                            if (IN_OBJ)
                                CAN_BE_ID = false;
                            else
                                IN_OBJ = false;
                            break;
                        case ":":
                        case "=":
                            CAN_BE_ID = true;
                    }
                    break;
            }
            lex.n();
        }


        return _identifiers_;
    }

    /* Templating Syntax */
    const barrier_a_start = "(";
    const barrier_a_end = ")";
    const barrier_b_start = "|";
    const barrier_b_end = "|";

    const BannedIdentifiers = { "true": true, "false": 1, "class": 1, "function": 1,  "return": 1, "for" : 1, "new" : 1, "let" : 1, "var" : 1, "const" : 1, "Date": 1};

    function setIdentifier(id, store, cache) {
        if (!cache[id] && !BannedIdentifiers[id]) {
            store.push(id);
            cache[id] = true;
        }
    }

    function processExpression(lex, binds) {

        /* 
         * The token after the second sentinel does not cover the entire bind range.
         * So the text with in the bind range should be a multi token token JS expression. 
         * We should extract all identifiers and use them to create bind points for an ExpressionIO.
         * 
         * The expression should work with a function return statement, as in:
         * ```javasript
         * "return (implied)" name ? "User has a name!" : "User does not have a name!"
         * ```
         */
        const bind_ids = [];

        const function_string = lex.slice();

        const existing_names = {};

        /**TODO? - This could be replaced by a plugin to ensure proper Javascript expressions. Perhaps producing a JS AST */
        let args = JSExpressionIdentifiers(lex);
        //console.log(function_string, args);

        for (let i = 0, l = args.length; i < l; i++)
            setIdentifier(args[i], bind_ids, existing_names);
        bind_ids.push(`return ${function_string}`);
        let funct = (Function).apply(null, bind_ids);

        const bindings = [];

        for (let i = 0, l = bind_ids.length - 1; i < l; i++) {
            let binding = new DynamicBinding();
            binding.tap_name = bind_ids[i];
            bindings.push(binding);
        }

        binds.push(new ExpressionBinding(bindings, funct));
    }

    /**
     * { function_description }
     * @memberof   module:wick~internals.compiler
     * @param      {Lexer}  lex     The lex
     * @return     {Array}   an
     */
    function evaluate(lex, EVENT$$1 = false) {

        let binds = [];


        lex.IWS = false;

        let start = lex.pos;
        while (!lex.END && lex.ty !== lex.types.str) {
            switch (lex.ch) {
                case barrier_a_start:
                    if (lex.pk.ch == barrier_b_start || lex.p.ch == barrier_a_start) {

                        let sentinel = (lex.p.ch == barrier_a_start) ? barrier_a_end : barrier_b_end;

                        let pk2 = lex.p.pk;


                        if (pk2.ch == barrier_b_start) {
                            sentinel = barrier_b_end;
                            if (start < lex.p.pos)
                                binds.push(new RawValueBinding(lex.p.slice(start)));

                            lex.p.sync();
                        } else if (start < lex.pos) {
                            //debugger
                            //console.log(lex.slice(start));
                            binds.push(new RawValueBinding(lex.slice(start)));
                        } //create text node


                        lex.sync().n();
                        lex.IWS = true; // Do not produce white space tokens during this portion.
                        let pk = lex.pk;


                        while (!pk.END && (pk.ch !== sentinel || (pk.pk.ch !== barrier_a_end && pk.p.ch !== barrier_a_start) || (pk.p.n().ch === barrier_a_end))) { pk.n(); }


                        if (lex.tl < pk.off - lex.off - 1) {
                            /***** Start Expression *******/

                            const elex = lex.copy(); //The expression Lexer

                            elex.fence(pk);

                            lex.sync();

                            if (pk.END) //Should still have `))` or `|)` in the input string
                                throw new Error("Should be more to this!");

                            processExpression(elex, binds);

                            lex.a(sentinel);
                            /***** End Expression ********/
                        } else {

                            /************************** Start Single Identifier Binding *******************************/
                            let id = lex.tx;
                            let binding = new DynamicBinding();
                            binding.tap_name = id;
                            let index = binds.push(binding) - 1;
                            lex.n().a(sentinel);

                            if (EVENT$$1) {
                                /***************************** Looking for Event Bindings ******************************************/
                                
                                if (lex.ch == barrier_a_start || lex.ch == barrier_b_start) {

                                    binds[index] = new EventBinding(binds[index]);

                                    let sentinel = (lex.ch == barrier_a_start) ? barrier_a_end : barrier_b_end;

                                    lex.IWS = true; // Do not produce white space tokens during this portion.

                                    let pk = lex.pk;

                                    while (!pk.END && (pk.ch !== sentinel || (pk.pk.ch !== barrier_a_end))) { pk.n(); }

                                    lex.n();

                                    if (lex.tl < pk.off - lex.off || BannedIdentifiers[lex.tx]) {

                                        const elex = lex.copy(); //The expression Lexer

                                        elex.fence(pk);

                                        lex.sync();

                                        if (pk.END) //Should still have `))` or `|)` in the input string
                                            throw new Error("Should be more to this!");

                                        const event_binds = [];

                                        processExpression(elex, event_binds);

                                        binds[index].bind = event_binds[0];

                                        lex.a(sentinel);

                                    } else {
                                        if (lex.ch !== sentinel) {
                                            let id = lex.tx,
                                                binding;
                                            if (lex.ty !== lex.types.id) {
                                                switch (lex.ty) {
                                                    case lex.types.num:
                                                        binding = new RawValueBinding(parseFloat(id));
                                                        break;
                                                    case lex.types.str:
                                                        binding = new RawValueBinding(id.slice(1, -1));
                                                        break;
                                                    default:
                                                        binding = new RawValueBinding(id.slice);
                                                }
                                            } else {
                                                binding = new DynamicBinding();
                                                binding.tap_name = id;
                                            }
                                            binds[index].bind = binding;
                                            lex.n();
                                        }
                                        lex.a(sentinel);
                                    }
                                }
                            }
                        }

                        lex.IWS = false;
                        
                        start = lex.off + 1; //Should at the sentinel.
                        
                        lex.a(barrier_a_end);
                        
                        continue;
                    }
                    break;
            }
            lex.n();
        }

        if (start < lex.off) {
            lex.off = start;
            lex.END = false;
            lex.tl = 0;
            lex.END = false;

            let DATA_END = start;

            while (!lex.n().END)
                if (!(lex.ty & (lex.types.ws | lex.types.nl)))
                    DATA_END = lex.off + lex.tl;
                
            if (DATA_END > start) {
                lex.sl = DATA_END;
                binds.push(new RawValueBinding(lex.slice(start)));
            }
        }

        return binds;
    }

    function Template(lex, FOR_EVENT) {
        let binds = evaluate(lex, FOR_EVENT);
        if (binds.length > 0) {
            if (binds.length == 1)
                return binds[0];
            return new OutTemplate(binds);
        }
        return null;
    }


    function OutTemplate(binds = []) {
        this._bindings_ = binds;
    }

    OutTemplate.prototype = {
        method: 0,

        attr: "",

        _bindings_: null,

        _bind_: function(source, errors, taps, element, attr) {
            if (this.method == ATTRIB || this.method == INPUT)
                return new AttribTemplate(source, errors, taps, attr, element, this._bindings_);
            return new TemplateString(source, errors, taps, element, this._bindings_);
        },

        _appendText_: function(string) {
            let binding = this._bindings_[this._bindings_.length - 1];

            if (binding && binding.type == RAW_VALUE_BINDING_ID) {
                binding.txt += string;
            } else {
                this._bindings_.push(new RawValueBinding(string));
            }
        },

        set type(v) {},
        get type() {
            return TEMPLATE_BINDING_ID;
        }
    };


    function StyleTemplate(lex) {

        const style = new OutStyleTemplate();
        return style;
    }

    class OutStyleTemplate {

        constructor() {
            this._css_props_ = [];
        }

        get _bindings_() {
            if (this._template_)
                return this._template_._bindings_;
            return [];
        }
        set _bindings_(v) {}

        get type() {
            return TEMPLATE_BINDING_ID;
        }
        set type(v) {}

        _addRule_(rule) {

            let props = rule.props;

            for (let name in props) {
                let prop = props[name];

                if (prop._wick_type_ > 0)
                    this._css_props_.push(prop);
                else 
                    this._css_props_.push(new CSSRawValue(name, prop));
            }

        }

        _bind_(source, errors, taps, element) {
            return new StyleIO(source, errors, taps, element, this._css_props_);
        }
    }

    function CSSRuleTemplate(lex, prop_name) {
        return new OutCSSRuleTemplate(lex, prop_name);
    }

    class OutCSSRuleTemplate {
        constructor(lex = null, prop_name = "") {
            let bindings = evaluate(lex);

            this.binding = null;

            this.prop_name = prop_name;

            this._bindings_ = bindings;
        }

        get _wick_type_() {
            return 1;
        }
        set _wick_type_(v) {}

        _bind_(source, errors, taps, io) {
            let binding = new CSSRuleTemplateString(source, errors, taps, this._bindings_, this.prop_name);
            binding.addIO(io);
            return binding;
        }
    }

    class BindingCSSRoot extends CSSRootNode {
        _getPropertyHook_(value_lex, prop_name, rule) {

            //looking for binding points
            let pk = value_lex.copy();
            while (!pk.END && ((pk.ch != barrier_a_start || (pk.n().ch != barrier_a_start && pk.ch != barrier_b_start)))) {
                pk.n();
            }

            if (pk.END)
                return false;

            rule.props[prop_name] = CSSRuleTemplate(value_lex, prop_name);

            return true;
        }
    }

    class RootText extends TextNode {
        constructor(binding) {
            super("");
            binding.method = TEXT$1;
            this.binding = binding;
        }

        _build_(element, source, presets, errors, taps) {
            let ele = document.createTextNode(this.txt);
            this.binding._bind_(source, errors, taps, ele);
            _appendChild_(element, ele);
        }

        _linkCSS_() {}
    }


    /**
     * Class for Root HTML AST Node.
     *@memberof module:wick~internals.templateCompiler
     *@alias Root
     */
    class RootNode extends HTMLNode {

        constructor() {
            super();
            this.HAS_TAPS = false;

            this.tap_list = [];
            this._bindings_ = [];

            this.pending_css = [];
            this.css = null;
            this._merged_ = false;

            this.__presets__ = null;
            this.__statics__ = null;
        }

        /******************************************* STATICS ****************************************************/



        get _statics_() {
            if (this.__statics__) return this.__statics__;

            if (this.par)
                return (this.__statics__ = Object.assign({}, this.par._statics_));

            return (this.__statics__ = {});
        }

        set _statics_(statics) {
            this.__statics__ = statics;
        }

        /******************************************* PRESETS ****************************************************/

        get _presets_() {
            if (this.__presets__) return this.__presets__;
            return this.par._presets_;
        }

        set _presets_(preset) {
            this.__presets__ = preset;
        }

        /****************************************** COMPONENTIZATION *****************************************/



        _mergeComponent_() {
            let component = this._presets_.components[this.tag];

            if (component)
                this._merged_ = component;

        }



        /******************************************* CSS ****************************************************/

        _setCSS_() {}

        _linkCSS_(css) {

            if (this.css)
                css = this.css;

            //parse rules and createBindings.
            if (css) {

                let rule = css.getApplicableRules(this);

                if (rule.LOADED) {

                    //Link into the binding for style. if there is no binding, create one. 
                    //Link in the rule properties to the tap system. 
                    let HAVE_BINDING = false;

                    for (let i = 0, l = this._attributes_.length; i < l; i++) {
                        let binding = this._attributes_[i];

                        if (binding.name == "css")
                            HAVE_BINDING = (binding.binding._addRule_(rule), true);
                    }

                    if (!HAVE_BINDING) {
                        let binding = StyleTemplate();
                        binding._addRule_(rule);
                        let vals = {
                            name: "css",
                            value: "",
                            binding
                        };
                        this._bindings_.push(vals);
                    }
                }
            }

            for (let node = this.fch; node; node = this.getN(node))
                node._linkCSS_(css);
        }

        _setPendingCSS_(css) {
            if (this.par)
                this.par._setPendingCSS_(css);
            else
                this.pending_css.push(css);
        }

        _getCSS_() {

            if (this.par)
                return this.par._getCSS_();

            if (this.css)
                return this.css;

            this.css = new BindingCSSRoot();

            this._setPendingCSS_(this.css);

            return this.css;
        }

        get classList() {
            let classes = this.getAttrib("class");
            if (classes) {
                if (typeof(classes.value) == "string")
                    return classes.value.split(" ");
                else
                    return classes.value.txt.split(" ");
            }
            return [];
        }

        /******************************************* TAPS ****************************************************/


        _getTap_(tap_name) {
            this.HAS_TAPS = true;
            const l = this.tap_list.length;
            for (let i = 0; i < l; i++)
                if (this.tap_list[i].name == tap_name)
                    return this.tap_list[i];
            const tap = {
                name: tap_name,
                id: l,
                _modes_: 0
            };
            this.tap_list.push(tap);
            return tap;
        }



        _checkTapMethod_(name, lex) {

            let tap_mode = KEEP; // Puts

            let SET_TAP_METHOD = false;

            switch (name[0]) {
                case "i": // Imports data updates, messages - valid on source and top level objects.
                    if (name === "import") {
                        SET_TAP_METHOD = true;
                        tap_mode |= IMPORT;
                    }
                    break;
                case "e": // Exports data updates, messages - valid on sources and top level objects.
                    if (name === "export") {
                        SET_TAP_METHOD = true;
                        tap_mode |= EXPORT;
                    }
                    break;
                case "p": // Pushes updates to model
                    if (name === "put") {
                        SET_TAP_METHOD = true;
                        tap_mode |= PUT;
                    }
            }

            if (SET_TAP_METHOD) {

                while (!lex.END) {

                    this._getTap_(lex.tx)._modes_ |= tap_mode;

                    lex.n();
                }

                return true;
            }
        }



        _checkTapMethodGate_(name, lex) {

            if (!this.par)
                return this._checkTapMethod_(name, lex);
            return false;
        }



        _linkTapBinding_(binding) {

            binding.tap_id = this._getTap_(binding.tap_name).id;
        }



        _delegateTapBinding_(binding, tap_mode) {

            if (this.par)
                return this.par._processTapBinding_(binding, tap_mode);

            return null;
        }



        _processTapBinding_(binding, tap_mode = 0) {

            if (this._delegateTapBinding_(binding, tap_mode)) return binding;

            if (binding.type === TEMPLATE_BINDING_ID) {

                let _bindings_ = binding._bindings_;

                for (let i = 0, l = _bindings_.length; i < l; i++)
                    if (_bindings_[i].type === DYNAMIC_BINDING_ID)
                        this._linkTapBinding_(_bindings_[i]);

            } else if (binding.type === DYNAMIC_BINDING_ID)
                this._linkTapBinding_(binding);

            return binding;
        }



        /******************************************* BUILD ****************************************************/



        /**
         * Builds Source Tree and Dom Tree.
         *
         * @param      {null}  element  The element
         * @param      {null}  source   The source
         * @param      {null}  presets  The presets
         * @param      {null   errors   The errors
         * @param      {null}  model    The model
         * @return     {null}  { description_of_the_return_value }
         */
        _build_(element, source, presets, errors, taps, statics) {

            const out_statics = this.__statics__ || statics;

            if (this._merged_) {
                
                source = this._merged_._build_(element, source, presets, errors, taps, out_statics);

            } else {

                source = source || new Source(null, presets, element, this);

                if (this.HAS_TAPS)
                    taps = source._linkTaps_(this.tap_list);

                let own_element = this._createElement_(presets);

                if (own_element) {
                    let hook = null;

                    if (this._bindings_.length > 0) {
                        hook = {
                            attr: this.attributes,
                            bindings: [],
                            style: null,
                            ele: own_element
                        };
                    }

                    source.hooks.push(hook);

                    for (let i = 0, l = this._bindings_.length; i < l; i++) {
                        let attr = this._bindings_[i];
                        let bind = attr.binding._bind_(source, errors, taps, own_element, attr.name);
                        if (hook) {
                            if (attr.name == "style" || attr.name == "css")
                                hook.style = bind;

                            hook.bindings.push(bind);
                        }
                    }

                    for (let node = this.fch; node; node = this.getN(node))
                        node._build_(own_element, source, presets, errors, taps, out_statics);

                    if(element)_appendChild_(element, own_element);

                    return source;
                }

            }


            for (let node = this.fch; node;
                (node = this.getN(node))) {
                node._build_(element, source, presets, errors, taps, out_statics);
            }

            return source;
        }



        /******************************************* HOOKS ****************************************************/

        /**
         * Override this method to tell the parser that `tag` is self closing and to not look for a matching close tag by returning `true`.
         * @param      {string}  tag     The HTML tag
         */
        _selfClosingTagHook_(tag) {
            switch (tag) {
                case "input":
                case "br":
                case "img":
                case "import":
                    return true;
            }

            return false;
        }

        _createElement_() {
            return _createElement_(this.tag);
        }

        _endOfElementHook_() {
            if (!this.fch) {
                this._mergeComponent_();
            }
        }


        /**
         * This will create TAP binding references and methods, binding points, and regular attribute nodes.
         * @param      {<type>}  name    The name
         * @param      {Lexer}  lex     The lex
         * @return     {Object}  `null` or an object to store in this nodes attributes
         * @private
         */
        _processAttributeHook_(name, lex) {

            let start = lex.off;

            let bind_method = ATTRIB,
                FOR_EVENT = false;

            let constr = Template;

            switch (name[0]) {

                case "#": //Static values
                    let key = name.slice(1);

                    if (key.length > 0) {
                        if (lex.tl == lex.sl - lex.off && lex.ty == lex.types.num)
                            this._statics_[key] = parseFloat(lex.slice());
                        else
                            this._statics_[key] = lex.slice();
                    }

                    return null;

                case "v": //Input
                    if (name == "value")
                        bind_method = INPUT;
                    break;

                case "o": // Event Messaging linking
                    if (name[1] == "n") {
                        FOR_EVENT = true;
                        bind_method = EVENT;
                    }
                    break;

                case "c":
                    if (name == "component") {
                        let component_name = lex.tx;
                        let components = this._presets_.components;
                        if (components)
                            components[component_name] = this;
                        return null;
                    }

            }

            if (this._checkTapMethodGate_(name, lex))
                return null;

            if ((lex.sl - lex.off) > 0) {
                let binding = constr(lex, FOR_EVENT);
                if (!binding) {
                    return {
                        name,
                        value: lex.slice(start)
                    };
                }

                binding.val = name;
                binding.method = bind_method;
                let attr = {
                    name,
                    value: (start < lex.off) ? lex.slice(start) : true,
                    binding: this._processTapBinding_(binding)
                };
                this._bindings_.push(attr);
                return attr;
            }

            let value = lex.slice(start);

            return {
                name,
                value: value || true
            };
        }



        /**
         * Hooks into the Text Node creation context and looks for binding points. 
         * If they are found, the text node will be made dynamic.
         * @param      {Lexer}    
         * @return     {TextNode}  
         */
        _processTextNodeHook_(lex) {

            if (lex.sl - lex.pos > 0) {

                let binding = Template(lex);
                if (binding)
                    return new RootText(this._processTapBinding_(binding));
            }

            return null;
        }
    }

    /**
     * Void elements don't exist, they evaporate into the void.
     * Element children of VoidNodes are appended to the last element created.
     */
    class VoidNode extends RootNode {

        _createElement_() { return null; }

        /******************************************* HOOKS ****************************************************/

        _endOfElementHook_() {}

        _processTextNodeHook_() {}

        /******************************************* BUILD ****************************************************/

        _build_() {}

        /******************************************* CSS ****************************************************/

        _linkCSS_() {}
    }

    class ScriptNode extends VoidNode {
        constructor() {
            super();
            this._script_text_ = "";
            this._binding_ = null;
        }

        _processTextNodeHook_(lex) {
            if (this._binding_)
                this._binding_.val = lex.slice();
        }

        _processAttributeHook_(name, lex) {

            switch (name) {
                case "on":
                    let binding = Template(lex, false);
                    if (binding.type == DYNAMIC_BINDING_ID) {
                        binding.method = SCRIPT;
                        this._binding_ = this._processTapBinding_(binding);
                    }
                    return null;
            }

            return { name, value: lex.slice() };
        }
        _build_(element, source, presets, errors, taps) {
            if (this._binding_)
                this._binding_._bind_(source, errors, taps, element);
        }
    }

    /**
     * Source nodes are used to hook into specific Models, and respond to `update` events from that model.
     * @class      SourceNode (name)
     */
    class SourceNode extends RootNode {
        constructor() {
            super();
            this._model_name_ = "";
            this._schema_name_ = "";
            this.statics = {};
        }

        _delegateTapBinding_() {
            return null;
        }

        _getCSS_() {

            if (this.css)
                return this.css;

            this.css = new BindingCSSRoot();

            this._setPendingCSS_(this.css);

            return this.css;
        }

        _checkTapMethodGate_(name, lex) {
            return this._checkTapMethod_(name, lex);
        }

        /******************************************* BUILD ****************************************************/

        _build_(element, source, presets, errors, taps = null, statics = null) {

            let data = {};

            let out_taps = [];

            let me = new Source(source, presets, element, this);

            me._model_name_ = this._model_name_;
            me._schema_name_ = this._schema_name_;

            let tap_list = this.tap_list;

            for (let i = 0, l = tap_list.length; i < l; i++) {
                let tap = tap_list[i],
                    name = tap.name;

                let bool = name == "update";

                me.taps[name] = bool ? new UpdateTap(me, name, tap._modes_) : new Tap(me, name, tap._modes_);

                if(bool)
                    me.update_tap = me.taps[name];
                
                out_taps.push(me.taps[name]);

            }

            for (let i = 0, l = this._attributes_.length; i < l; i++) {
                let attr = this._attributes_[i];

                if (!attr.value) ; else {
                    data[attr.name] = attr.value;

                }
            }

            for (let node = this.fch; node; node = this.getN(node))
                node._build_(element, me, presets, errors, out_taps, statics);

            if (statics) {
                me._statics_ = statics;
                me._update_(statics);
            }


            return me;
        }

        /******************************************* HOOKS ****************************************************/

        _endOfElementHook_() {}

        /**
         * Pulls Schema, Model, or tap method information from the attributes of the tag. 
         * All other attributes are passed through without any other consideration.
         * @param      {string}  name    The name
         * @param      {Lexer}  lex     The lex
         * @return     {Object}  Key value pair.
         */
        _processAttributeHook_(name, lex, value) {
            switch (name[0]) {
                case "#":
                    return null;
                case "m":
                    if (name == "model") {
                        this._model_name_ = lex.slice();
                        lex.n();
                    }
                    break;
                case "s":
                    if (name == "schema") {
                        this._schema_name_ = lex.slice();
                        lex.n();
                    }
                    break;
                case "c":
                    if (name == "component") {
                        let component_name = lex.tx;
                        let components = this._presets_.components;
                        if (components)
                            components[component_name] = this;
                        return null;
                    }
                    break;
                default:
                    if (this._checkTapMethodGate_(name, lex))
                        return null;
            }

            return { name, value: lex.slice() };
        }
    }

    class LinkNode extends RootNode {
        _createElement_(presets){
            let element = document.createElement("a");
            presets.processLink(element);
            return element;
        }
    }

    /**
     * SourceTemplate provide the mechanisms for dealing with lists and sets of components. 
     *
     * @param      {Source}  parent   The Source parent object.
     * @param      {Object}  data     The data object hosting attribute properties from the HTML template. 
     * @param      {Object}  presets  The global presets object.
     * @param      {HTMLElement}  element  The element that the Source will _bind_ to. 
     */
    class SourceTemplate extends View {

        constructor(parent, presets, element) {

            super();

            //super(parent, presets, element);
            this.ele = element;
            this.parent = null;
            this.activeSources = [];
            this._filters_ = [];
            this._ios_ = [];
            this.terms = [];
            this.sources = [];
            this.range = null;
            this._SCHD_ = 0;
            this._prop_ = null;
            this._package_ = null;
            this.transition_in = 0;

            parent.addTemplate(this);
        }

        get data() {}
        set data(container) {

            if (container.length > 0) {
                if (Array.isArray(container))
                    this.cull(container);
                else
                    this.cull(container.data);
            }
        }

        _update_(container) {

            //let results = container.get(this.getTerms());
            if (container.length > 0) {
                if (Array.isArray(container))
                    this.cull(container);
                else
                    this.cull(container.data);
            }
        }

        /**
         * Called by Scheduler when a change is made to the Template HTML structure. 
         * 
         * @protected
         */
        _scheduledUpdate_() {
            for (let i = 0; i < this.activeSources.length; i++)
                this.activeSources[i]._transitionIn_(i);
        }

        /**
         * Filters stored Sources with search terms and outputs the matching Sources to the DOM.
         * 
         * @protected
         */
        filterUpdate() {

            let output = this.sources.slice();

            if(output.length < 1) return;

            for (let i = 0, l = this._filters_.length; i < l; i++) {
                let filter = this._filters_[i];

                if (filter._CAN_USE_) {

                    if (filter._CAN_FILTER_)
                        output = output.filter(filter._filter_function_._filter_expression_);                

                    if (filter._CAN_SORT_)
                        output = output.filter(filter._sort_function_);
                }
            }

            let j = 0,
                ol = output.length;

            for (let i = 0; i < ol; i++)
                output[i].index = i;

            for (let i = 0; i < this.activeSources.length; i++) {
                let as = this.activeSources[i];
                if (as.index > j) {
                    let ele = as.ele;
                    while (j < as.index && j < ol) {
                        let os = output[j];
                        os.index = -1;
                        this.ele.insertBefore(os.ele, ele);
                        j++;
                    }
                    j++;
                } else if (as.index < 0) {
                    as._transitionOut_();
                } else {
                    j++;
                }
                as.index = -1;
            }

            while (j < output.length) {
                this.ele.appendChild(output[j].ele);
                output[j].index = -1;
                j++;
            }

            this.ele.style.position = this.ele.style.position;

            this.activeSources = output;

            scheduler.queueUpdate(this);
        }

        /**
         * Removes stored Sources that do not match the ModelContainer contents. 
         *
         * @param      {Array}  new_items  Array of Models that are currently stored in the ModelContainer. 
         * 
         * @protected
         */
        cull(new_items) {

            if(!new_items) return;

            if (new_items.length == 0) {

                for (let i = 0, l = this.sources.length; i < l; i++)
                    this.sources[i]._destroy_();

                this.sources.length = 0;

            } else {

                let exists = new Map(new_items.map(e => [e, true]));

                var out = [];

                for (let i = 0, l = this.activeSources.length; i < l; i++)
                    if (!exists.has(this.activeSources[i].model)) {
                        this.activeSources[i]._transitionOut_();
                        this.activeSources.splice(i, 1);
                        l--;
                        i--;
                    } else
                        exists.set(this.activeSources[i].model, false);


                for (let i = 0, l = this.sources.length; i < l; i++)
                    if (!exists.has(this.sources[i].model)) {
                        this.sources[i]._destroy_();
                        this.sources.splice(i, 1);
                        l--;
                        i--;
                    } else
                        exists.set(this.sources[i].model, false);


                exists.forEach((v, k, m) => { if (v) out.push(k); });

                if (out.length > 0)
                    this.added(out);
            }
        }

        /**
         * Called by the ModelContainer when Models have been removed from its set.
         *
         * @param      {Array}  items   An array of items no longer stored in the ModelContainer. 
         */
        removed(items) {

            for (let i = 0; i < items.length; i++) {
                let item = items[i];

                for (let j = 0; j < this.sources.length; j++) {
                    let Source = this.sources[j];

                    if (Source._model_ == item) {
                        this.sources.splice(j, 1);
                        Source.dissolve();
                        break;
                    }
                }
            }

            this.filterUpdate();
        }

        /**
         * Called by the ModelContainer when Models have been added to its set.
         *
         * @param      {Array}  items   An array of new items now stored in the ModelContainer. 
         */
        added(items) {

            for (let i = 0; i < items.length; i++) {
                let ele = _createElement_("li");
                let mgr = this._package_.mount(ele, items[i], false);

                mgr.sources.forEach((s) => { s.parent = this.parent;});

                this.sources.push(mgr);
            }

            for (let i = 0; i < this.sources.length; i++) {
                this.parent.addSource(this.sources[i]);
            }

            this.filterUpdate();
        }

        revise() {
            if (this.cache)
                this._update_(this.cache);
        }


        getTerms() {

            let out_terms = [];

            for (let i = 0, l = this.terms.length; i < l; i++) {
                let term = this.terms[i].term;
                if (term) out_terms.push(term);

            }


            if (out_terms.length == 0)
                return null;

            return out_terms;
        }

        get() {
            if (this._model_ instanceof MultiIndexedContainer) {
                if (this.data.index) {
                    let index = this.data.index;

                    let query = {};

                    query[index] = this.getTerms();

                    return this._model_.get(query)[index];
                } else
                    console.warn("No index value provided for MultiIndexedContainer!");
            } else {
                let source = this._model_.source;
                let terms = this.getTerms();

                if (source) {
                    this._model_._destroy_();

                    let model = source.get(terms, null);

                    model.pin();
                    model.addView(this);
                }

                return this._model_.get(terms);
            }
            return [];
        }
    }

    class FilterIO extends IOBase {
        constructor(source, errors, taps, template, activation, sort, filter) {
            super(template, errors);
            this.template = template;
            this._activation_function_ = null;
            this._sort_function_ = null;
            this._filter_function_ = null;
            this._CAN_USE_ = false;
            this._CAN_FILTER_ = false;
            this._CAN_SORT_ = false;
            this._SCHD_ = 0;

            if (activation && activation.binding){
                this._activation_function_ = activation.binding._bind_(source, errors, taps, this);
            } else{
                this._CAN_USE_ = true;
            }

            if (sort && sort.binding) {
                /** See {@link ExpressionBinding} **/
                let expr = sort.binding;
                if (expr.type == 2 && typeof(expr.func) == "function"){
                    this._sort_function_ = expr.func;
                    this._CAN_SORT_ = true;
                } 
            }

            if (filter && filter.binding) {
                /** See {@link ExpressionBinding} **/
                let expr = filter.binding;
                if (expr.type == 2 && typeof(expr.func) == "function"){
                    this._filter_function_ = expr._bind_(source, errors, taps, this);
                    this._filter_function_._IS_A_FILTER_ = true;
                    this._CAN_FILTER_ = true;  
                } 
            }
        }

        _scheduledUpdate_() {
            this.template.filterUpdate();
        }
        
        update(){
            scheduler.queueUpdate(this);
        }

        _destroy_() {
            if (this._sort_function_)
                this._sort_function_._destroy_();
            if (this._activation_function_)
                this._activation_function_._destroy_();
            if (this._filter_function_)
                this._filter_function_._destroy_();
            this._sort_function_ = null;
            this._activation_function_ = null;
            this._filter_function_ = null;
            this.template = null;
        }

        get data() {}
        set data(v) {
            let cache = this._CAN_USE_;
            this._CAN_USE_ = false;
            if (v) this._CAN_USE_ = true;

            if(cache !== this._CAN_USE_)
                this.update();
        }
    }

    class FilterNode extends VoidNode {

        /******************************************* HOOKS ****************************************************/

        _endOfElementHook_() {}

        /**
         * This node only needs to assess attribute values. InnerHTML will be ignored. 
         * @return     {boolean}  { description_of_the_return_value }
         */
        _selfClosingTagHook_() { return true; }

    }

    class PackageNode extends VoidNode {

        constructor(start) {
            super();
            this._start_ = start;
        }

        /******************************************* HOOKS ****************************************************/

        /**
         * Binds new laxer to boundaries starting from open tag to close tag. Applies Lexer to new SourcePackage.
         * @param      {Lexer}  lex     The lex
         * @private
         */
        _processTextNodeHook_(lex) {

            let own_lex = lex.copy();

            let pk = own_lex.pk;

            own_lex.tl = 0;

            own_lex.off = this._start_;

            own_lex.n().sl = own_lex.str.length;

            while (!pk.n().END && (pk.ch !== "<" || pk.n().ch !== "/" || pk.n().tx !== this.tag || pk.n().ch !== ">"));

            own_lex.sl = pk.off + pk.tl;

            this.par._package_ = new this.SourcePackage(own_lex, this._presets_, false);
        }

        _ignoreTillHook_() { return true; }

        _endOfElementHook_() {
            if (!this.fch)
                this._mergeComponent_();
        }

        _mergeComponent_() {
            let component = this._presets_.components[this.tag];

            if (component)
                this.par._package_ = new this.SourcePackage(component, this._presets_, false);
        }
    }

    class SourceTemplateNode extends RootNode {
        constructor(lex) {
            super();
            this.BUILD_LIST = [];
            this.filters = [];
            this._property_bind_ = null;
            this._package_ = null;
        }

        _build_(element, source, presets, errors, taps) {

            source = source || new Source(null, presets, element, this);

            if (this.HAS_TAPS)
                taps = source._linkTaps_(this.tap_list);

            if (this._property_bind_ && this._package_) {

                let ele = _createElement_("ul");
                let me = new SourceTemplate(source, presets, ele);
                me._package_ = this._package_;
                me.prop = this._property_bind_._bind_(source, errors, taps, me);

                _appendChild_(element, ele);

                for (let node = this.fch; node; node = this.getN(node)) {
                    //All filter nodes here
                    
                    let on = node.getAttrib("on");
                    let sort = node.getAttrib("sort");
                    let filter = node.getAttrib("filter");

                    if (sort || filter) //Only create Filter node if it has a sorting bind or a filter bind
                        me._filters_.push(new FilterIO(source, errors, taps, me, on, sort, filter));
                }
            }

            return source;
        }

        /******************************************* HOOKS ****************************************************/

        _endOfElementHook_() {}

        _ignoreTillHook_() {}

        _createHTMLNodeHook_(tag, start) {
            switch (tag) {
                case "f":
                    return new FilterNode(); //This node is used to 
                default:
                    return new PackageNode(start); //This node is used to build packages
            }
        }

        _processTextNodeHook_(lex) {
            if (!this._property_bind_) {
                let cp = lex.copy();
                lex.IWS = true;
                cp.tl = 0;
                if (cp.n().ch == barrier_a_start && (cp.n().ch == barrier_a_start || cp.ch == barrier_b_start)) {
                    let binding = Template(lex);
                    if (binding)
                        this._property_bind_ = this._processTapBinding_(binding);
                }
            }
        }
    }

    class StyleNode extends VoidNode {
        _processTextNodeHook_(lex) {
            //Feed the lexer to a new CSS Builder
            let css = this._getCSS_();
            lex.IWS = true;
            lex.tl = 0;
            lex.n();

            css._parse_(lex).catch((e) => {
                throw e;
            });
        }
    }

    //Since all nodes extend the RootNode, this needs to be declared here to prevent module cycles. 
    function CreateHTMLNode(tag) {
        //jump table.
        switch (tag[0]) {
            case "w":
                switch (tag) {
                    case "w-s":
                        return new SourceNode(); //This node is used to 
                    case "w-c":
                        return new SourceTemplateNode(); //This node is used to 
                }
                break;
            default:
                switch (tag) {
                    case "a":
                        return new LinkNode();
                    /** void elements **/
                    case "template":
                        return new VoidNode();
                    case "style":
                        return new StyleNode();
                    case "script":
                        return new ScriptNode();
                    
                }
        }

        return new RootNode();
    }

    RootNode.prototype._createHTMLNodeHook_ = CreateHTMLNode;

    /**
     * Factory object for Creating Source trees.  Encapsulates construction information derived from the HTML AST.  
     * 
     * @param      {HTMLElement}  element      The element
     * @param      {Function}  constructor      The constructor for the object the Skeleton will create.
     * @param      {Object}  data  Data pulled from a tags attributes
     * @param      {Presets}  presets  The global Presets instance.
     * @memberof module:wick~internals.source
     * @alias Skeleton  
     */
    class Skeleton {

        /**
            Constructor of Skeleton
        */
        constructor(tree, presets) {
            this.tree = tree;
            this._presets_ = presets;
        }


        /**
         * Constructs Source tree and returns that. 
         * @param {HTMLElement} element - host HTML Element. 
         * @param      {<type>}  primary_model    The model
         * @return     {<type>}  { description_of_the_return_value }
         */
        flesh(element, primary_model = null) {

            let Source = this.____copy____(element, null, primary_model);

            if (Source)
                Source.load(primary_model);

            return Source;
        }

        /**
         * Extends a given DOM tree and, optionally, a Source tree with it's own internal  tree.
         * @param {HTMLElement} parent_element - HTML Element of the originating Source. 
         * @param {<type>}  parent_source   The parent source
         */
        extend(parent_element = null, parent_source = null) {
            this.____copy____(parent_element, parent_source);
        }

        /**
            Constructs a new object, attaching to elements hosted by a Source object. If the component to be constructed is a Source the 
            parent_element HTMLElement gets swapped out by a cloned HTMLElement that is hosted by the newly constructed Source.

            @param {HTMLElement} parent_element - HTML Element of the originating tree. 

            @protected
        */
        ____copy____(parent_element = null, parent_source = null, primary_model = null) {
            //List of errors generated when building DOM
            let errors = [];

            let source = this.tree._build_(parent_element, parent_source, this._presets_, errors);

            if (errors.length > 0) {
                //TODO!!!!!!Remove all _bindings_ that change Model. 
                //source.kill_up_bindings();
                errors.forEach(e => console.log(e));
            }

            return source;
        }
    }

    function complete(lex, SourcePackage, presets, ast) {
        /*
         * Only accept certain nodes for mounting to the DOM. 
         * The custom element `import` is simply used to import extra HTML data from network for use with template system. It should not exist otherwise.
         */
        if (ast.tag && ast.tag !== "import" && ast.tag !== "template") {
            let skeleton = new Skeleton(ast, presets);
            SourcePackage._skeletons_.push(skeleton);
        }

        lex.IWS = true;

        while (!lex.END && lex.ch != "<") { lex.n(); }
        if (!lex.END)
            return parseText(lex, SourcePackage, presets);

        SourcePackage._complete_();

        return SourcePackage;
    }


    function buildCSS(lex, SourcePackage, presets, ast, css_list, index) {
        return css_list[index]._READY_().then(() => {
            
            if(++index < css_list.length) return buildCSS(lex, SourcePackage, presets, ast, css_list, index);

            ast._linkCSS_();

            return complete(lex, SourcePackage, presets, ast);
        });
    }

    function parseText(lex, SourcePackage, presets) {
        let start = lex.off;

        while (!lex.END && lex.ch != "<") { lex.n(); }

        if (!lex.END) {

            if (lex.pk.ty != lex.types.id)
                throw new Error("Expecting an Identifier after `<` character");

            let node = CreateHTMLNode(lex.p.tx);

            node._presets_ = presets;

            return node._parse_(lex).then((ast) => {
                if (ast.pending_css.length > 0) 
                    return buildCSS(lex, SourcePackage, presets, ast, ast.pending_css, 0);
                
                return complete(lex, SourcePackage, presets, ast);
            }).catch((e) => {
                SourcePackage._addError_(e);
                SourcePackage._complete_();
            });
        }
        SourcePackage._addError_(new Error(`Unexpected end of input. ${lex.slice(start)}, ${lex.str}`));
        SourcePackage._complete_();
    }


    /**
     * Compiles an object graph based input into a SourcePackage.
     * @param      {SourcePackage}  SourcePackage     The source package
     * @param      {Presets}  presets           The global Presets instance
     * @param      {HTMLElement | Lexer | string}  element     The element
     * @memberof module:wick~internals.templateCompiler
     * @alias CompileSource
     */
    function CompileSource(SourcePackage, presets, element) {
        let lex;
        if (element instanceof Lexer) {
            lex = element;
        } else if (typeof(element) == "string")
            lex = new Lexer(element);
        else if (element instanceof EL) {
            if (element.tagName == "TEMPLATE") {
                let temp = document.createElement("div");
                temp.appendChild(element.content);
                element = temp;
            }
            lex = new Lexer(element.outerHTML);
        } else {
            let e = new Error("Cannot compile component");
            SourcePackage._addError_(e);
            SourcePackage._complete_();
        }
        return parseText(lex, SourcePackage, presets);
    }

    /**
     * SourcePackages stores compiled {@link SourceSkeleton}s and provide a way to _bind_ Model data to the DOM in a reusable manner. * 
     * @property    {Array}    _skeletons_        
     * @property    {Array}    styles       
     * @property    {Array}    scripts      
     * @property    {Array}    style_core    
     * @readonly
     * @callback   If `RETURN_PROMISE` is set to `true`, a new Promise is returned, which will asynchronously return a SourcePackage instance if compilation is successful.
     * @param      {HTMLElement}  element      The element
     * @param      {Presets}  presets      The global Presets object.
     * @param      {boolean}  [RETURN_PROMISE=false]  If `true` a Promise will be returned, otherwise the SourcePackage instance is returned. 
     * @return     {SourcePackage | Promise}  If a SourcePackage has already been constructed for the given element, that will be returned instead of new one being created. If 
     * @memberof module:wick.core.source
     * @alias SourcePackage  
     */
    class SourcePackage {

        constructor(element, presets, RETURN_PROMISE = false) {

            //If a package exists for the element already, it will be bound to __wick__package__. That will be returned.
            if (element.__wick__package__) {
                if (RETURN_PROMISE)
                    return new Promise((res) => res(element.__wick__package__));
                return element.__wick__package__;
            }


            /**
             * When set to true indicates that the package is ready to be mounted to the DOM.
             */
            this._READY_ = false;

            /**
             * An array of SourceSkeleton objects.
             */
            this._skeletons_ = [];

            /**
             * An array objects to store pending calls to SourcePackage#mount
             */
            this.pms = [];

            /**
             * An Array of error messages received during compilation of template.
             */
            this._errors_ = [];

            /**
             * Flag to indicate SourcePackage was compiled with errors
             */
            this._HAVE_ERRORS_ = false;

            if (element instanceof Promise) {
                element.then((data) => CompileSource(this, presets, data));
                if (RETURN_PROMISE) return element;
                return this;
            } else if (element instanceof RootNode) {
                //already a HTMLtree, just package into a skeleton and return.
                this._skeletons_.push(new Skeleton(element, presets));
                this._complete_();
                return;
            } else if (!(element instanceof EL) && typeof(element) !== "string" && !(element instanceof Lexer)) {
                let err = new Error("Could not create package. element is not an HTMLElement");
                this._addError_(err);
                this._complete_();
                if (RETURN_PROMISE)
                    return new Promise((res, rej) => rej(err));
                return;
            }

            //Start the compiling of the component.
            let promise = CompileSource(this, presets, element);

            OB.seal(this);

            if (RETURN_PROMISE)
                return promise;
            else
                return this;

        }

        /**
         * Called when template compilation completes. 
         * 
         * Sets SourcePackage#_READY_ to true, send the pending mounts back through SourcePackage#mount, and freezes itself.
         * 
         * @protected
         */
        _complete_() {
            this._READY_ = true;

            for (let m, i = 0, l = this.pms.length; i < l; i++)
                (m = this.pms[i], this.mount(m.e, m.m, m.usd, m.mgr));


            this.pms.length = 0;

            this._fz_();
        }

        /**
         * Adds Error message to the errors array.
         *
         * @param      {String}  error_message     the error message to add.
         * 
         * @protected
         */
        _addError_(error_message) {
            this._HAVE_ERRORS_ = true;
            //Create error skeleton and push to _skeletons_
            this._errors_.push(error_message);
            console.error(error_message);
        }

        /**
         * Freezes properties.
         * @protected 
         */
        _fz_() {
            return;
            OB.freeze(this._READY_);
            OB.freeze(this._skeletons_);
            OB.freeze(this.styles);
            OB.freeze(this.pms);
            OB.freeze(this._errors_);
            OB.freeze(this);
        }

        /**
         * Pushes pending mounts to the pms array.
         *
         * @param      {HTMLElement}  element         The element
         * @param      {Model}  model           The model
         * @param      {Boolean}  USE_SHADOW_DOM  The use shadow dom
         * @param      {Object}  manager         The manager
         * 
         * @protected
         */
        _pushPendingMount_(element, model, USE_SHADOW_DOM, manager) {

            if (this._READY_)
                return this.mount(element, model, USE_SHADOW_DOM, manager);

            this.pms.push({
                e: element,
                m: model,
                usd: USE_SHADOW_DOM,
                mgr: manager
            });

            return manager;
        }

        /**
         * Generates new instance of component and appends it to the input element.
         * @param  {HTMLElement} element         - The element
         * @param  {Model}   model           - The model
         * @param  {boolean} USE_SHADOW_DOM  - If `true`, appends the component to the element's ShadowDOM.
         * @param  {Object}  manager         - The manager
         */
        mount(element, model, USE_SHADOW_DOM = false, manager = new SourceManager(model, element)) {

            if (!this._READY_)
                return this._pushPendingMount_(element, model, USE_SHADOW_DOM, manager);

            if (!(element instanceof EL)) return null;

            if (this._HAVE_ERRORS_) {
                //Process
                console.warn("TODO - Package has errors, pop an error widget on this element!");
            }
            let i = 0,
                l = 0;

            if (!manager.sources)
                manager.sources = [];

            if (USE_SHADOW_DOM) {

                let shadow_root = element.attachShadow({
                    mode: "open"
                });

                element = shadow_root;

                for (i = 0, l = this.styles.length; i < l; i++) {
                    let style = _cloneNode_(this.styles[i], true);
                    _appendChild_(element, style);
                }
            }

            for (i = 0, l = this._skeletons_.length; i < l; i++) {
                let source = this._skeletons_[i].flesh(element, model);
                manager.sources.push(source);
            }

            if (manager.sourceLoaded) manager.sourceLoaded();

            return manager;
        }
    }

    PackageNode.prototype.SourcePackage = SourcePackage;

    /**
     * Page visualization of the data that model contains.
     *
     * @class      PageView (name)
     */
    class PageView {

        constructor(URL, app_page) {

            this.url = URL;
            this.eles = [];
            this.finalizing_view = null;
            this.type = "normal";
            if (!app_page) debugger
            this.ele = app_page;
            this.ele_backer = null;
            this.LOADED = false;

            console.log(this);
        }

        _destroy_() {

            for (var i = 0; i < this.eles.length; i++) {
                let element = this.eles[i];
                element._destroy_();
            }

            this.eles = null;
            this.ele = null;
        }

        unload(transitions) {

            this.LOADED = false;
            
            for (var i = 0; i < this.eles.length; i++) {
                let element = this.eles[i];
                element.getTransformTo(transitions);
                element.unloadComponents();
            }
        }

        transitionOut(transitions) {

            let time = 0;

            for (var i = 0; i < this.eles.length; i++) 
                time = Math.max(time, this.eles[i].transitionOut(transitions));
            

            return time;
        }

        finalize() {

            if(this.LOADED) return;

            for (var i = 0; i < this.eles.length; i++) {
                let element = this.eles[i];
                element.finalize();
            }

            if (this.ele.parentElement)
                this.ele.parentElement.removeChild(this.ele);
        }

        load(app_element, wurl) {

            this.LOADED = true;
            
            for (var i = 0; i < this.eles.length; i++) {
                let element = this.eles[i];
                element.loadComponents(wurl);
            }

            app_element.appendChild(this.ele);

            var t = this.ele.style.opacity;
        }

        transitionIn(transitions) {

            if (this.type == "modal") {
                if (!this.ele_backer) {
                    this.ele_backer = document.createElement("div");
                    this.ele_backer.classList.add("modal_backer");
                    this.ele.appendChild(this.ele_backer);
                }
                setTimeout(() => {
                    this.ele.style.opacity = 1;
                }, 50);
            }

            for (var i = 0; i < this.eles.length; i++) {
                let element = this.eles[i];
                element.parent = this;
                //element.setTransformTo(transitions);
                element.transitionIn();
            }        
        }

        getNamedElements(named_elements) {

            for (var i = 0; i < this.eles.length; i++) {
                let element = this.eles[i];
                element.getNamedElements(named_elements);
            }
        }

        compareComponents() {
            //This will transition objects
        }

        setType(type) {
            this.type = type || "normal";
        }
    }

    const ease_out = new CBezier(0.5, 0.2, 0, 1);

    if (!requestAnimationFrame)
        requestAnimationFrame = (e) => {
            setTimeout(e, 1000);
        };

    class TT_From {
        constructor(element) {
            //extracted animatable components
            var rect = element.getBoundingClientRect();

            this.color = new Color(window.getComputedStyle(element, null).getPropertyValue("background-color"));
            this.height = parseFloat(window.getComputedStyle(element, null).getPropertyValue("height"));
            this.width = parseFloat(window.getComputedStyle(element, null).getPropertyValue("width"));

            //*if(!this.height || !this.width){
            this.height = rect.height;
            this.width = rect.width;
            //}*/


            this.left = parseFloat(rect.left);
            this.top = parseFloat(rect.top);

            this.ele = element;

        }

        _destroy_() {
            this.ele = null;
            this.color = null;
        }

        _start_() {
            this.ele.style.opacity = 0;
        }

        end() {
            this.ele.style.opacity = 1;
        }
    }

    class TT_To extends TT_From {
        constructor(element, from) {
            super(element);

            this.from = from;

            this.res = ((element.style.top) && (element.style.left));

            this.rt = (element.style.top) ? (element.style.top) : null;
            this.rl = element.style.left ? element.style.left : null;


            //get the relative offset of this object
            var offset_x = 0; - element.getParentWindowLeft();
            var offset_y = 0; - element.getParentWindowTop();

            var offset_x = parseFloat(window.getComputedStyle(element, null).getPropertyValue("left"));
            var offset_y = parseFloat(window.getComputedStyle(element, null).getPropertyValue("top"));
            //And adjust _start_ to respect the elements own parental offsets
            var diffx = this.left - this.from.left;
            this.left = offset_x;
            this.from.left = this.left - diffx;

            var diffy = this.top - this.from.top;
            this.top = offset_y;
            this.from.top = this.top - diffy;

            this.time = 60 * .35;
            this.s = 0;
            this.color_o = window.getComputedStyle(element, null).getPropertyValue("background-color");
            this.height_o = element.style.width;
            this.width_o = element.style.height;
            this.top_o = this.top;
            this.left_o = this.left;
            this.pos = window.getComputedStyle(element, null).getPropertyValue("position");


        }

        _destroy_() {
            this.end(); //Restore everything back to it's original type;
            this.from = null;
            this.s = Infinity;
            this.ele = null;
            super._destroy_();
        }

        _start_() {
            this.ele.style.opacity = 1;
            this.ele.style.top = this.from.top + "px";
            this.ele.style.left = this.from.left + "px";
            this.ele.style.width = this.from.width + "px";
            this.ele.style.height = this.from.height + "px";
        }

        _step_() {
            this.s++;

                var t = this.s / this.time;

            if (t > 1) return false;

            var ratio = ease_out.getYatX(t);

            if (ratio > 1) ratio = 1;

            this.ele.style.top = Math.round((this.top - this.from.top) * ratio + this.from.top) + "px";
            this.ele.style.left = Math.round((this.left - this.from.left) * ratio + this.from.left) + "px";
            this.ele.style.width = ((this.width - this.from.width) * ratio + this.from.width) + "px";
            this.ele.style.height = ((this.height - this.from.height) * ratio + this.from.height) + "px";
            this.ele.style.backgroundColor = (this.color.sub(this.from.color).mult(ratio).add(this.from.color)) + "";

            return (t < 0.9999995);
        }

        end() {
            this.ele.style.backgroundColor = null;
            this.ele.style.height = this.height_o;
            this.ele.style.width = this.width_o;
            this.ele.style.top = this.rt;
            this.ele.style.left = this.rl;
        }
    }


    class TTPair {
        constructor(e_to, e_from) {
            this.b = (e_from instanceof TT_From) ? e_from : new TT_From(e_from);
            this.a = new TT_To(e_to, this.b);

            if (this.a.ele.__TT__)
                this.a.ele.__TT__._destroy_();

            if (this.b.ele.__TT__)
                this.b.ele.__TT__._destroy_();

            this.a.ele.__TT__ = this;
            this.b.ele.__TT__ = this;

            this.destroyed = false;

            this._start_();
        }

        _destroy_() {
            if (this.destroyed) return
            if (this.b.ele)
                this.b.ele.__TT__ = null;
            if (this.a.ele)
                this.a.ele.__TT__ = null;
            this.a._destroy_();
            this.destroyed = true;
        }

        _start_() {
            this.b._start_();
            this.a._start_();
        }

        _step_() {
            return this.a._step_();
        }
    }

    const TransformRunner = new(class {
        constructor() {
            this.pairs = [];
            this._SCHD_ = 0;
        }

        _pushPair_(pair) {
            this.pairs.push(pair);
            scheduler.queueUpdate(this);
        }

        _scheduledUpdate_(ratio) {
            let rp = this.pairs;

            if (rp.length > 0)
                scheduler.queueUpdate(this);

            for (var i = 0; i < rp.length; i++) {
                var _rp = rp[i];
                if (!_rp._step_(ratio)) {
                    _rp._destroy_();
                    rp.splice(i, 1);
                    i--;
                }        }


        }
    })();


    /**
        Transform one element from another back to itself
        @alias module:wick~internals.TransformTo
    */
    function TransformTo(element_from, element_to, HIDE_OTHER) {


        if (!element_to) {

            let a = (from) => (element_to, HIDE_OTHER) => {
                let pair = new TTPair(element_to, from);
                TransformRunner._pushPair_(pair);
            };

            let b = a(new TT_From(element_from));

            return b;
        }

        var pair = new TTPair(element_to, element_from);

        TransformRunner._pushPair_(pair);

        pair._start_();
    }



    var Animation = /*#__PURE__*/Object.freeze({
        TransformTo: TransformTo
    });

    /**
     * The base class for all components
     * @param      {HTMLElement}  element  The DOM `<component>` element that the Component can append sub elements to. It may be replaced by a different type of element if necessary, is in the case with an ErrorComponent.
     * @memberof module:wick~internals.component
     * @alias BaseComponent
     */
    class BaseComponent {

        constructor(element) {
            /**
             * The HTML element the component will append elements to. 
             */
            this.ele = element;

            /**
             * Set to `true` if the component's `ele` element is currently appended to the main document.
             */
            this.LOADED = false;
        }

        /**
         * Returns a list of all elements that have a name attribute.
         * @param      {Object}  named_elements  Object to _bind_ named elements to.
         */
        getNamedElements(named_elements) {
            let children = this.ele.children;

            for (var i = 0; i < children.length; i++) {
                let child = children[i];

                if (child.dataset.transition) {
                    named_elements[child.dataset.transition] = child;
                }
            }
        }

        /**
         * Called by the hosting Element when it is mounted to the active page. 
         * Allows the component to react to changes observed in the URL of the website. 
         */
        handleUrlUpdate() {}

        /**
         * Called by the hosting Element when it is mounted to the active page. 
         * Allows the component to apply a transition in effect. 
         */
        transitionIn() {}

        /**
         * Called by the hosting Element before it is unmounted from the active page. 
         * Allows the component to apply a transition out effect. 
         * @override
         */
        transitionOut() {}
    }


    /**
     * Component attaches an error message to the `<component>`.  It allows JS errors to show in client space.
     * @param      {HTMLElement}  element        Ignored by this class
     * @param      {(string | Error)}  error_message  The error message or object to display.
     * @param      {Presets}  presets        The global Presets object. 
     * @alias FailedComponent
     * @memberof module:wick~internals.component
     * @extends BaseComponent
     */
    class FailedComponent extends BaseComponent {
        constructor(element, error_message, presets) {
            super(document.createElement("div"));
            this.ele.innerHTML = `<h3> This Wick component has failed!</h3> <h4>Error Message:</h4><p>${error_message.stack}</p><p>Please contact the website maintainers to address the problem.</p> <p>${presets.error_contact}</p>`;
        }
    }

    /**
     * Builds out a `<component>` trough the Wick templating system. 
     * @param      {HTMLElement}  element                 The element
     * @param      {Presets}  presets                 The global Presets object
     * @param      {Object}  app_components          The application components
     * @param      {Object}  component_constructors  The component constructors
     * @param      {Object}  model_constructors      The model constructors
     * @param      {HTMLElement}  WORKING_DOM             The working dom
     * @memberof module:wick~internals.component
     * @alias Component
     * @return     {Component}  If this object is already cached in app_components, returns the existing cached object. 
     * @extends BaseComponent
     */
    class Component extends BaseComponent {

        constructor(element, presets, DOM, app_components) {

            super(element);

            /**
             * The {@link Model} the 
             */
            this._model_ = null;

            /**
             * All {@link Source}s bound to this component from a {@link SourcePackag}.
             */
            this.sources = [];

            /**
             *  Set to true by Element when the Element mounts the component to the document.
             */
            this.ACTIVE = false;

            const id = element.classList[0];



            if (id && app_components[id])
                return app_components[id];
            if (presets.custom_sources[id])
                presets.custom_sources[id].mount(this.ele, this);
            else {
                let template = DOM.getElementById(id);
                let url = element.getAttribute("url");
                if (template && template.tagName == "TEMPLATE") {
                    (new SourcePackage(template, presets)).mount(this.ele, null, presets.options.USE_SHADOW, this);
                } else if (url) {
                    (new WURL(url))
                    .fetchText()
                        .then(text => {
                            (new SourcePackage(text, presets)).mount(this.ele, null, presets.options.USE_SHADOW, this);
                        });
                } else {
                    (new SourcePackage(this.ele.innerHTML, presets)).mount(this.ele, null, presets.options.USE_SHADOW, this);
                }
            }


            app_components[id] = this;
        }

        /**
         * @override
         */
        transitionOut() {

            if (!this.LOADED || !this.ACTIVE) {
                this.ACTIVE = false;
                return 0;
            }

            this.ACTIVE = false;

            let t = 0;

            return t;
        }

        /**
         * @override
         */
        transitionIn() {

            if (!this.LOADED || this.ACTIVE) {
                this.ACTIVE = true;
                return 0;
            }

            this.ACTIVE = true;
        }

        /**
         * @override
         */
        bubbleLink(link_url, child, trs_ele = {}) {

            this.bubbled_elements = trs_ele;

            history.pushState({}, "ignored title", link_url);

            window.onpopstate();
        }

        /**
         * @override
         */
        getTransformTo(transitions) {
            if (transitions) {
                let own_elements = {};

                this.getNamedElements(own_elements);

                for (let name in own_elements) {
                    transitions[name] = TransformTo(own_elements[name]);
                }
            }
        }

        /**
         * @override
         */
        setTransformTo(transitions) {
            if (transitions) {
                let own_elements = {};

                this.getNamedElements(own_elements);

                for (let name in own_elements) {
                    let to, from = transitions[name];
                    if ((to = own_elements[name]) && from) {
                        from(to, false);
                    }
                }
            }
        }

        /**
         * @override
         */
        getNamedElements(named_elements) {
            if (this.bubbled_elements) {
                let t = this.bubbled_elements;

                for (let t in this.bubbled_elements)
                    named_elements[t] = this.bubbled_elements[t];

                //this.bubbled_elements = null;

                return;
            }

            let children = this.ele.children;

            for (var i = 0; i < children.length; i++) {
                let child = children[i];

                if (child.dataset.transition) {
                    named_elements[child.dataset.transition] = child;
                }
            }

            for (var i = 0; i < this.sources.length; i++) {
                // let component = this.components[i];
                // component.getNamedElements(named_elements);
            }
        }

        sourceLoaded() { this.handleUrlUpdate(); }

        /**
         * @override
         */
        handleUrlUpdate(wurl = new WURL("", true)) {

            let query_data = wurl.getData();

            for (let i = 0, l = this.sources.length; i < l; i++)
                this.sources[i]._update_(query_data, null, true);
        }
    }

    /**
     * Class for element.
     *
     * @class      Element (name)
     * 
     * Elements are the root scope for a set of components. 
     * If two pages share the same element name, then the will remain mounted on the page as it transitions to the next. 
     * Elements are used to determine how one page transitions into another. 
     */
    class Element$1 {
        /**
         * Constructs an Element.
         *
         * @param      {HTMLElement}  element  The HTMLElement that this Element will be bound to. 
         */
        constructor(element) {
            this.id = (element.classList) ? element.classList[0] : element.id;
            this.components = [];
            this.bubbled_elements = null;
            this.wraps = [];

            //The original element container.
            //this.parent_element = parent_element;

            //Content that is wrapped in an ele_wrap
            this.ele = element;
        }


        unloadComponents() {
            for (var i = 0; i < this.components.length; i++)
                this.components[i].LOADED = false;
        }

        transitionOut() {

            let t = 0;

            for (var i = 0; i < this.components.length; i++) {

                let component = this.components[i];

                if (!component.LOADED) {

                    component.parent = null;

                    t = Math.max(component.transitionOut(), t);
                }
            }

            return t;
        }

        finalize() {

            for (var i = 0; i < this.components.length; i++) {

                let component = this.components[i];

                if (!component.LOADED && component.parentElement) {
                    component.finalizeTransitionOut();
                    this.wraps[i].removeChild(component.ele);
                }

                component.LOADED = false;
            }
        }

        loadComponents(wurl) {


            for (let i = 0; i < this.components.length; i++) {

                let component = this.components[i];

                component.parent = this;

                if (component.ele.parentElement)
                    component.ele.parentElement.removeChild(component.ele);

                this.wraps[i].appendChild(component.ele);

                component.handleUrlUpdate(wurl);

                this.components[i].LOADED = true;
            }    }

        transitionIn() {

            // This is to force a document repaint, which should cause all elements to report correct positioning hereafter

            let t = this.ele.style.top;
            this.ele.style.top = t;

            for (let i = 0; i < this.components.length; i++) {
                let component = this.components[i];

                component.transitionIn();

            }
        }

        bubbleLink(link_url, child, trs_ele = {}) {

            this.bubbled_elements = trs_ele;

            history.pushState({}, "ignored title", link_url);

            window.onpopstate();
        }

        getTransformTo(transitions) {
            if (transitions) {
                let own_elements = {};

                this.getNamedElements(own_elements);

                for (let name in own_elements) {
                    transitions[name] = TransformTo(own_elements[name]);
                }
            }
        }

        setTransformTo(transitions) {
            if (transitions) {
                let own_elements = {};

                this.getNamedElements(own_elements);


                for (let name in own_elements) {
                    let to, from = transitions[name];
                    if ((to = own_elements[name]) && from) {
                        from(to, false);
                    }
                }
            }
        }

        getNamedElements(named_elements) {
            if (this.bubbled_elements) {
                let t = this.bubbled_elements;

                for (let t in this.bubbled_elements)
                    named_elements[t] = this.bubbled_elements[t];

                //this.bubbled_elements = null;

                return;
            }

            let children = this.ele.children;

            for (var i = 0; i < children.length; i++) {
                let child = children[i];

                if (child.dataset.transition) {
                    named_elements[child.dataset.transition] = child;
                }
            }

            for (var i = 0; i < this.components.length; i++) {
                let component = this.components[i];
                component.getNamedElements(named_elements);
            }
        }

        setComponents(App_Components, Model_Constructors, Component_Constructors, presets, DOM, wurl) {
            //if there is a component inside the element, register that component if it has not already been registered

            var components = Array.prototype.map.call(this.ele.getElementsByTagName("component"), (a) => a);


            if (components.length < 1) {
                //Create a wrapped component for the elements inside the <element>
                let component = document.createElement("div");

                component.classList.add("comp_wrap");

                //Straight up string copy of the element's DOM.
                component.innerHTML = this.ele.innerHTML;
            }

            for (var i = 0; i < components.length; i++) {
                let app_component = null;
                let component = components[i];

                try {

                    /**
                        Replace the component with a component wrapper to help preserve DOM arrangement
                    */
                    //*
                    let comp_wrap = document.createElement("div");
                    comp_wrap.classList.add("comp_wrap");
                    this.wraps.push(comp_wrap);
                    component.parentElement.replaceChild(comp_wrap, component);
                    //*/

                    var id = component.dataset.class;
                    /**
                      We must ensure that components act as template "landing spots". In order for that to happen we must check for:
                      (1) The component has, as it's first class name, an id that (2) matches the id of a template. If either of these prove to be not true, we should reject the adoption of the component as a Wick
                      component and instead treat it as a normal "pass through" element.
                    */

                    if (!id) {
                        app_component = new Component(component, presets, DOM, App_Components, Component_Constructors, Model_Constructors);

                        app_component.handleUrlUpdate(wurl);
                    } else {

                        let custom_component = presets.custom_components[id];

                        if (custom_component)
                            app_component = new custom_component(component, presets, DOM);


                    }
                } catch (e) {
                    console.log(e);

                    app_component = new FailedComponent(component, e, presets);
                }

                if (!app_component)
                    app_component = new FailedComponent(component, e, presets);

                this.components.push(app_component);
            }
        }
    }

    /** @namespace Router */

    /**
     * Returns the `<modal>` element from the document DOM, or creates and appends a new one to `<body>`.
     */
    function getModalContainer() {
        let modal_container = document.getElementsByTagName("modals")[0];

        if (!modal_container) {

            modal_container = document.createElement("modals");

            var dom_app = document.getElementsByTagName("app")[0];

            if (dom_app)
                dom_app.parentElement.insertBefore(modal_container, dom_app);
            else
                document.body.appendChild(modal_container);
        }

        return modal_container;
    }

    /**
     * Responsible for loading pages dynamically, handling the transition of page components, and monitoring and reacting to URL changes
     *
     * @memberof   module:wick~internal
     * @param      {Presets}  presets  A {@link Presets} object.
     * @package
     * @alias Router
     */
    class Router {

        /**
         * Constructs the object.
         *
         */
        constructor(presets) {
            console.log(presets);

            presets.router = this;

            this.pages = {};
            this.elements = {};
            this.component_constructors = presets.custom_sources;
            this.models_constructors = presets.schemas;
            this._presets_ = presets;
            this.current_url = null;
            this.current_query = null;
            this.current_view = null;
            this.finalizing_pages = [];

            presets.processLink = (temp) => {

                if (!temp.onclick) temp.onclick = (e) => {
                    let link = e.currentTarget;
                    if (link.origin !== location.origin) return;
                    e.preventDefault();
                    history.pushState({}, "ignored title", link.href);
                    window.onpopstate();
                };
            };

            /* */
            this.modal_stack = [];

            window.onpopstate = () => {
                this.parseURL(document.location);
            };
        }

        /*
            This function will parse a URL and determine what Page needs to be loaded into the current view.
        */
        parseURL(location) {

            let url = location.pathname;

            let IS_SAME_PAGE = (this.current_url == url),
                page = null,
                wurl = new WURL(location.href);

            this.current_url = url;

            if ((page = this.pages[url])) {

                if (IS_SAME_PAGE) {

                    return page.transitionIn(
                        (page.type == "modal") ? getModalContainer() : document.getElementsByTagName("app")[0],
                        null, wurl, IS_SAME_PAGE);
                }

                return this.loadPage(page, wurl, IS_SAME_PAGE);
            }

            if (location)
                fetch(location.href, {
                    credentials: "same-origin", // Sends cookies back to server with request
                    method: 'GET'
                }).then((response) => {

                    (response.text().then((html) => {

                        var DOM = (new DOMParser()).parseFromString(html, "text/html");

                        this.loadPage(
                            this.loadNewPage(url, DOM, wurl),
                            wurl,
                            IS_SAME_PAGE
                        );
                    }));
                }).catch((error) => {
                    console.warn(`Unable to process response for request made to: ${this.url}. Response: ${error}. Error Received: ${error}`);
                });
        }

        finalizePages() {

            if (this.armed) {

                let a = this.armed;
                //  a.p.transitionIn(a.e, this.current_view, a.wurl, a.SP, a.te);
                this.armed = null;
            }

            for (var i = 0, l = this.finalizing_pages.length; i < l; i++) {

                var page = this.finalizing_pages[i];

                page.finalize();
            }

            this.finalizing_pages.length = 0;
        }

        /**
         * Loads pages from server, or from local cache, and sends it to the page parser.
         * @param {String} url - The URL id of the cached page to load.
         * @param {String} query -
         * @param {Bool} IS_SAME_PAGE -
         */
        loadPage(page, wurl = new WURL(document.location.href), IS_SAME_PAGE) {

            let transition_length = 0;

            let app_ele = document.getElementsByTagName("app")[0];

            //Finalize any existing page transitions;
            // this.finalizePages();

            let transition_elements = {};

            if (page.type == "modal") {

                //trace modal stack and see if the modal already exists
                if (IS_SAME_PAGE) {

                    page.transitionIn();

                    return;
                }

                let UNWIND = 0;

                for (var i = 0, l = this.modal_stack.length; i < l; i++) {

                    let modal = this.modal_stack[i];

                    if (UNWIND == 0) {

                        if (modal == page)
                            UNWIND = i + 1;

                    } else {

                        let trs = 0;

                        modal.unload();

                        if (trs = modal.transitionOut()) {

                            transition_length = Math.max(trs, transition_length);

                            this.finalizing_pages.push(modal);
                        } else
                            modal.finalize();
                    }
                }

                if (UNWIND > 0) {
                    this.modal_stack.length = UNWIND;
                    page.load(getModalContainer(), wurl);
                    page.transitionIn();
                } else {
                    //create new modal
                    this.modal_stack.push(page);
                    page.load(getModalContainer(), wurl);
                    page.transitionIn();
                }

            } else {

                for (var i = 0, l = this.modal_stack.length; i < l; i++) {

                    let modal = this.modal_stack[i];

                    let trs = 0;

                    modal.unload();

                    if ((trs = modal.transitionOut())) {
                        transition_length = Math.max(trs, transition_length);
                        this.finalizing_pages.push(modal);
                    } else
                        modal.finalize();

                }

                this.modal_stack.length = 0;

                if (this.current_view && this.current_view != page) {

                    this.current_view.unload(transition_elements);

                    page.load(app_ele, wurl);

                    let t = this.current_view.transitionOut();

                    window.requestAnimationFrame(() => {
                        page.transitionIn(transition_elements);
                    });

                    transition_length = Math.max(t, transition_length);

                    this.finalizing_pages.push(this.current_view);
                } else if (!this.current_view) {

                    page.load(app_ele, wurl);

                    window.requestAnimationFrame(() => {
                        page.transitionIn(transition_elements);
                    });
                }

                this.current_view = page;
            }

            setTimeout(() => {
                this.finalizePages();
            }, (transition_length * 1000) + 1);
        }

        /**
            Pre-loads a custom constructor for an element with the specified id and provides a model to that constructor when it is called.
            The constructor must have Element in its inheritance chain.
        */
        addStatic(element_id, constructor, model) {

            this.component_constructors[element_id] = {
                constructor,
                model_name: model
            };

        }

        /**
            Creates a new iframe object that acts as a modal that will sit ontop of everything else.
        */
        loadNonWickPage(URL) {

            let iframe = document.createElement("iframe");
            iframe.src = URL;
            iframe.classList.add("modal", "comp_wrap");
            var page = new PageView(URL, iframe);
            page.type = "modal";
            this.pages[URL] = page; //new Modal(page, iframe, getModalContainer());
            return this.pages[URL];
        }
        /**
            Takes the DOM of another page and strips it, looking for elements to use to integrate into the SPA system.
            If it is unable to find these elements, then it will pass the DOM to loadNonWickPage to handle wrapping the page body into a wick app element.
        */
        loadNewPage(URL, DOM, wurl = new WURL("", true)) {

            //look for the app section.


            /**
                If the page should not be reused, as in cases where the server does all the rendering for a dynamic page and we're just presenting the results,
                then having NO_BUFFER set to true will cause the linker to not save the page to the hashtable of existing pages, forcing a request to the server every time the page is visited.
            */
            let NO_BUFFER = false;

            /* 
                App elements: There should only be one. 
            */
            let app_list = DOM.getElementsByTagName("app");

            if (app_list.length > 1)
                console.warn(`Wick is designed to work with just one <app> element in a page. There are ${app_list.length} apps elements in ${url}. Wick will proceed with the first <app> element in the DOM. Unexpected behavior may occur.`);

            let app_source = app_list[0];

            /**
              If there is no <app> element within the DOM, then we must handle this case carefully. This likely indicates a page delivered from the same origin that has not been converted to work with the Wick system.
              The entire contents of the page can be wrapped into a <iframe>, that will be could set as a modal on top of existing pages.
            */
            if (!app_source) {
                console.warn("Page does not have an <app> element!");
                return this.loadNonWickPage(URL);
            }

            var app_page = document.createElement("apppage");

            app_page.innerHTML = app_source.innerHTML;

            var app = app_source.cloneNode(true);

            var dom_app = document.getElementsByTagName("app")[0];

            var page = new PageView(URL, app_page);


            if (app_source) {

                if (app_source.dataset.modal == "true") {

                    page.setType("modal");
                    let modal = document.createElement("modal");
                    modal.innerHTML = app.innerHTML;
                    app.innerHTML = "";
                    app = modal;

                    /*
                        If the DOM is the same element as the actual document, then we shall rebuild the existing <app> element, clearing it of it's contents.
                    */
                    if (DOM == document && dom_app) {
                        let new_app = document.createElement("app");
                        document.body.replaceChild(new_app, dom_app);
                        dom_app = new_app;
                    }
                }

                if (app.dataset.no_buffer == "true")
                    NO_BUFFER = true;

                var elements = app_page.getElementsByTagName("element");

                for (var i = 0; i < elements.length; i++) {

                    let ele = elements[i],
                        element;


                    let element_id = ele.id;

                    if (page.type !== "modal") {

                        element = new Element$1(ele);

                    } else {

                        let new_ele = document.createElement("div");

                        new_ele.innerHTML = ele.innerHTML;

                        new_ele.classList.add("ele_wrap");

                        element = new Element$1(ele);
                    }

                    page.eles.push(element);

                    if (!this.elements[element_id])
                        this.elements[element_id] = {};

                    element.setComponents(this.elements[element_id], this.models_constructors, this.component_constructors, this._presets_, DOM, wurl);
                }

                if (document == DOM)
                    dom_app.innerHTML = "";

                let result = page;

                if (!NO_BUFFER) this.pages[URL] = result;

                return result;
            }
        }
    }

    /** This is the entire object structure of Wick, minus the platform specific outputs found in /source/root/ */

    const model$1 = (data, schema) => new SchemedModel(data, undefined, undefined, schema);
    model$1.scheme = (schema, sm) => (sm = class extends SchemedModel {}, sm.schema = schema, sm);

    model$1.constr = SchemedModel;
    model$1.any = (data) => new Model(data);
    model$1.any.constr = Model;
    model$1.container = {
        multi: MultiIndexedContainer,
        array: ArrayModelContainer,
        btree: BTreeModelContainer,
        constr: ModelContainerBase
    };
    model$1.store = (data) => new Store(data);

    //Construct Schema Exports
    const scheme = Object.create(schemes);
    scheme.constr = SchemeConstructor;
    scheme.constr.bool = BoolSchemeConstructor;
    scheme.constr.number = NumberSchemeConstructor;
    scheme.constr.string = StringSchemeConstructor;
    scheme.constr.date = DateSchemeConstructor;
    scheme.constr.time = TimeSchemeConstructor;

    Object.freeze(scheme.constr);
    Object.freeze(scheme);
    Object.freeze(Presets);
    Object.freeze(model$1.container.constr);
    Object.freeze(model$1.container);
    Object.freeze(model$1.any);
    Object.freeze(model$1);

    const core = {
        presets: a => new Presets(a),
        common: Common,
        lexer: (string, INCLUDE_WHITE_SPACE_TOKENS) => new Lexer(string, INCLUDE_WHITE_SPACE_TOKENS),
        animation: Animation,
        view: View,
        css: CSSParser,
        html: HTMLParser,
        scheme: scheme,
        model: model$1,
        network: {
            url: WURL,
            router: Router
            /*,
                    getter: Getter,
                    setter: Setter,*/
        },
        source: (...a) => new SourcePackage(...a)
    };

    let internals = { /* Empty if production */ };
    internals.lexer = Lexer;
    internals.scheduler = scheduler;

    core.source.package = SourcePackage;

    Object.freeze(core.source);
    Object.freeze(core);

    let source = core.source;

    const wick_vanity = "\ \(\ \ \(\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \)\n\ \)\\\)\)\(\ \ \ \'\ \(\ \ \ \ \ \ \ \ \ \ \(\ \/\(\n\(\(\_\)\(\)\\\ \)\ \ \)\\\ \ \ \ \(\ \ \ \ \)\\\(\)\)\n\_\(\(\)\)\\\_\)\(\)\(\(\_\)\ \ \ \)\\\ \ \(\(\_\)\\\n\\\ \\\(\(\_\)\/\ \/\ \(\_\)\ \ \(\(\_\)\ \|\ \|\(\_\)\n\ \\\ \\\/\\\/\ \/\ \ \|\ \|\ \/\ \_\|\ \ \|\ \/\ \/\n\ \ \\\_\/\\\_\/\ \ \ \|\_\|\ \\\_\_\|\ \ \|\_\\\_\\\n";


    let LINKER_LOADED = false;


    /**
     *    Creates a new Router instance, passing any presets from the client.
     *    It will then wait for the document to complete loading then starts the Router and loads the current page into the Router.
     *
     *    Note: This function should only be called once. Any subsequent calls will not do anything.
     *    @method startRouting
     *    @param {Object} presets_options - An object of configuration data to pass to the Presets. {@link Presets}.
     */
    function startRouting(preset_options = {}) {

        if (LINKER_LOADED) return;

        LINKER_LOADED = true;

        let router = new core.network.router(core.presets(preset_options));

        window.addEventListener("load", () => {
            router.loadPage(
                router.loadNewPage(document.location.pathname, document),
                new core.network.url(document.location),
                false
            );
        });

        console.log(`${wick_vanity}Copyright 2018 Anthony C Weathersby\nhttps://gitlab.com/anthonycweathersby/wick`);

        return {preset_options, router};
    }

    exports.source = source;
    exports.scheme = scheme;
    exports.model = model$1;
    exports.core = core;
    exports.internals = internals;
    exports.startRouting = startRouting;

    return exports;

}({}));
