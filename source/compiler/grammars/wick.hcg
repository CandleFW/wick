@NAME CFW Wick Parser

@EXT wick

@SYMBOL </ 

@IGNORE θws θnl 

@IMPORT ../../../node_modules/@candlefw/js/source/grammar/ecmascript.hcg as js

@IMPORT ./html.hcg as html

@IMPORT ./wickup.hcg as wickup

@IMPORT ../../../node_modules/@candlefw/css/source/grammar/css.hcg as css 

<> S → start																				↦r{ $sym1 }

<> start → html::HTML
#	 │ js::javascript 

#+> js::primary_expression → html::TAG 														↦r { new fn.js_wick_node($sym1) }

+> html::BODY →  (IMPORT_TAG)(+) html::GOAL_TAG 												↦return { $sym2.import_list = $sym1, $sym2}
	
#+> html::TAG_BODY_ITEM → < τstyle html::ATTRIBUTES? >  css::CSS?  </ τstyle > 				↦return { fn.element_selector($$sym2, $$sym3, $$sym5,  env, lex ) }
#	│ < τscript html::ATTRIBUTES? > js::script? </ τscript > 								↦return { fn.element_selector($$sym2, $$sym3, $$sym5,  env, lex ) }
#	│ < τjs html::ATTRIBUTES? > js::script? </ τjs > 										↦return { fn.element_selector($$sym2, $$sym3, $$sym5,  env, lex ) }
	#│ \{ js::expression \{ js::script? \} \}												↦r {fn.element_selector("script", ["on", null, new env.wick_binding(["on",null, $sym2])], $sym4, env, lex) }

<> IMPORT_TAG → < τimport html::ATTRIBUTES? /? > ( </ τimport > )?  							↦return { fn.element_selector($$sym2, $$sym3, null,  env, lex ) }

+> html::VOID_NAME →  τf
		│ τfilter

#+> html::ATTRIBUTE_BODY → WICK_BINDING 									
#	│ " WICK_BINDING " 																		↦return { $sym2 }

#+> html::TEXT_NODE → WICK_BINDING 															↦cstr ^text

#<> WICK_BINDING → CALL_BINDING  							
# 	│ BASIC_BINDING
 
#<> BASIC_BINDING → \( (ERR θws ) \( ↦{ env.start = lex.off+2 } js::expression? \) (ERR θws ) \)   									↦r {(env.off = lex.off, new fn.wick_binding($$sym3, null, env, lex) )}
#<> CALL_BINDING → \( (ERR θws ) \( ↦{ env.start = lex.off+2 } js::expression? \) (ERR θws ) \( js::expression? \) (ERR θws ) \)    	↦r {(env.off = lex.off, new fn.wick_binding($$sym3, $$sym6, env, lex) )}
