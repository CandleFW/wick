# → - Production start
# │ - Alternate production  
# θ - Generated Terminal
# τ - Literal Terminal
# ↦ - Function Start
# ɛ - Empty Production

# This grammar represents a subset of ECMAscript syntax for use by the CandleFW wick compiler.

body → statement_list                                   ↦ cstr return sym[0];

#
# https://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-statements-and-declarations
#

statement_list → statement                              ↦ cstr return sym[0];
               # │ binary_expressions                             ↦ cstr return sym[0];
               │ statement_list ; statement             ↦ cstr this.members = [sym[0], sym[2]]; this.t = "statement_list";
               # declerations

statement → expression                                 ↦ cstr return sym[0];
          │ ɛ

expression → assignment_expression                      
           │ expression , assignment_expression         ↦ cstr this.members = [sym[0], sym[2]]; this.t = "expression_list";

#
# https://www.ecma-international.org/ecma-262/6.0/#sec-left-hand-side-expressions
#

left_hand_expression → call_expression                 ↦ cstr return sym[0];

call_expression →  member_expression                    ↦ cstr return sym[0];
               # │ member_expression  arguments        ↦ cstr return sym[1];
               # │ call_expression arguments            ↦ cstr return sym[1];
               # │ call_expression [ expression ]       ↦ cstr return sym[1];
               # │ call_expression . id                 ↦ cstr return sym[1];

member_expression → primary_expression                 ↦ cstr return sym[0];
                │ member_expression [ expression ]       ↦ cstr this.owner = sym[0]; this.member = sym[2]; this.t = "member"
                │ member_expression . id                 ↦ cstr this.owner = sym[0]; this.member = sym[2]; this.t = "member"


arguments → ( )                 # Returns nothing
          │ ( argument_list )   ↦ cstr return sym[1];

argument_list → assignment_expression                           ↦ cstr return sym[0];
              │ . . . assignment_expression                     ↦ cstr this.expr = sym[3]; this.t = "spread";
              │ argument_list, assignment_expression            ↦ cstr this.members = [...sym[0], sym[2]]; this.t = "assignement_list";
              │ argument_list, . . . assignment_expression      ↦ cstr this.members = [...sym[0], ...sym[2]]; this.t = "assignement_list";

#
# https://www.ecma-international.org/ecma-262/6.0/#sec-unary-operators
#

primary_expression → τthis                                  ↦ cstr this.t = "this";
                   │ id                                     ↦ cstr return sym[0];
                   │ num                                    ↦ cstr return sym[0];
                   │ null                                   ↦ cstr return sym[0];
                   │ boolean_literal                        ↦ cstr return sym[0];
                   │ ( expression )                         ↦ cstr return sym[1];
                   

assignment_expression → left_hand_expression assignement_op assignment_expression     ↦ cstr this.left=sym[0]; this.op = sym[1]; this.right = sym[2];
                    │ conditional                       ↦ cstr return sym[0];       ↦ cstr return sym[0];     

assignement_op → =
             │ + =                                      ↦ cstr return {t:"plus eq"};
             │ -=                                       ↦ cstr return {t:"minus eq"};
             │ *=                                       ↦ cstr return {t:"mul eq"};
             │ /=                                       ↦ cstr return {t:"div eq"};
             │ <<=
             │ >>=
             │ >>>=
             │ &=
             │ ^=
             │ |=

conditional → binary_expressions ? binary_expressions : binary_expressions ↦ cstr this.bool=sym[0]; this.true_state = sym[2]; this.false_state = sym[4];
            │ binary_expressions                        ↦ cstr return sym[0];

binary_expressions → be                                 ↦ cstr return sym[0];

be →  be * be                                        ↦ cstr this.l = sym[0]; this.r = sym[2]; this.type="multiply"
    │ be / be                                        ↦ cstr this.l = sym[0]; this.r = sym[2]; this.type="divide" 
    # │ be + be               %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="add"
    # │ be - be               %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="sub"
    # │ be % be               %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="modulo"
    # │ be & be               %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="bit and"                   
    # │ be ^ be               %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="bit xor"
    # │ be | be               %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="bit or"
    # │ be << be              %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="shift left"
    # │ be >> be              %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="shift right"
    # │ be >>> be             %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="shift fill right"
    # │ be < be               %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="greator"
    # │ be > be               %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="lesser"
    # │ be <= be              %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="gr eq"
    # │ be >= be              %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="ls eq"
    # │ be == be              %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="equal"
    # │ be != be              %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="not eq"
    # │ be === be             %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="abs eq"
    # │ be !== be             %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="abs neq"
    # │ be || be              %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="log or"
    # │ be && be              %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="log and"
    # │ be τinstanceof be     %%1                         ↦ cstr this.l = sym[0]; this.r = sym[0]; this.type="instanceof"
    │ unary_expression                                  ↦ cstr return sym[0];
    # │ string_literal                                  ↦ cstr return sym[0];
    

unary_expression → prefix_expression                   ↦ cstr return sym[0];
                 │ + prefix_expression   %%1           ↦ cstr this.v = sym[1]; this.type="positive"
                 │ - prefix_expression   %%1            ↦ cstr this.v = sym[1]; this.type="negative"
                 │ ! unary_expression    %%0            ↦ cstr this.v = sym[1]; this.type="log not unary"
                 │ ~ unary_expression    %%0            ↦ cstr this.v = sym[1]; this.type="bit not unary"

prefix_expression → postfix_expression                   ↦ cstr return sym[0];
                 │ + + prefix_expression  %%0            ↦ cstr this.v = sym[2]; this.type="increment"
                 │ - - prefix_expression  %%0            ↦ cstr this.v = sym[2]; this.type="decrement"

postfix_expression → left_hand_expression               ↦ cstr return sym[0];
                │ left_hand_expression + +              ↦ cstr this.v = sym[0]; this.type="post increment"
                │ left_hand_expression - -              ↦ cstr this.v = sym[0]; this.type="post decrement"

boolean_literal → τtrue         ↦ cstr this.t = "true";
                │ τfalse        ↦ cstr this.t = "false";


#
# https://www.ecma-international.org/ecma-262/6.0/#sec-literals-string-literals
#
# string_literal  → " string_chars " ↦ cstr return sym[1];

string_literal → θstring 

null → τnull        ↦ cstr this.t = "null";

id → θid         ↦ cstr this.v = sym[0]; this.t = "identifier";
num → θnum       ↦ cstr this.v = parseFloat(sym[0]); this.t = "number";

future_keyword → τimplements 
                │ τpackage 
                │ τprotected 
                │ τinterface
                │ τprivate 
                │ τpublic

keyword →  τbreak │ τdo │ τin │ τtypeof 
        │ τcase │ τelse │ τinstanceof │ τvar 
        │ τcatch │ τexport │ τnew │ τvoid 
        │ τclass │ τextends │ τreturn │ τwhile 
        │ τconst │ τfinally │ τsuper │ τwith 
        │ τcontinue │ τfor │ τswitch │ τyield 
        │ τdebugger │ τfunction │ τthis 
        │ τdefault │ τif │ τthrow 
        │ τdelete │ τimport │ τtry
